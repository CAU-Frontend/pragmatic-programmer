# 나는 실용주의 프로그래머가 될 수 있다.

- 실용주의 프로그래머는 책임감이 있기 때문에 프로젝트가 방치된 채로 끝장나는 걸 지켜보고만 있지 않는다.
- 프로젝트를 깨끗하게 유지하는 방법을 안다.

# ch.01 실용주의 철학

## 내 인생이다.

개발자는 구직자에게 주도권이 있다.
하지만 개발자들은 변화를 피하고, 상황이 나아지길 기다린다.
그래서 이 팁이 책에서 가장 중요한 팁이다.

```
나에게는 Agency가 있다.
```

문제를 고치기 위해 노력해라.
나는 내 조직을 변화시키거나, 조직을 이동할 수 있다.

기술에 뒤쳐지는 기분이 든다면 재미있어 보이는 것을 공부해라.

## 😺냥이가 내 코드를 먹어버렸다.

'약점을 보이는 것에 대한 두려움이 가장 큰 약점이다.'

우리는 자신의 능력에 자부심을 가질 수 있지만, 실수나 무지 같은 단점도 인정해야 한다.(이건 개발에만 해당되는 것은 아닌 것 같다.)

**팀 내 신뢰**
팀이 날 믿고 의지할 수 있어야 한다.
나도 팀을 믿고 의지할 수 있어야 한다.

신뢰를 바탕으로 만들어진 건강한 환경이어야 비로소 제대로 된 소통이 가능하다.(공감)

신뢰에 한 번 구멍이 뚫리면 원상 복구가 어렵다(연애랑 똑같다. 연에 === 프로젝트)

**책임지기**

최선을 다하는 것이 책임의 전부가 아니다.
불가능하거나, 위험이 큰 상황에서는 책임을 맡지 않을 권리가 있다.
내 가치관과 판단에 따라 결정해라.

책임을 지기로 했다면, 그 결과에 대한 감당이 필요하다.
실수를 했거나, 잘못된 판단을 내렸다면, 정직하게 인정하고 바로잡아라.

```
어설픈 변명 말고 대안을 제시하라.
```

코드가 날아갔는데, 백업이 없다면 내 잘못이다. 고양이가 내 코드를 먹어버렸어요. 라고 하는건 별 도움이 안된다.
변명하지 말고, 다른 방안을 제안해보자.

'잘 모르겠어요' 라고 대답했다면, 바로 이어서 '알아볼게요' 라고 얘기해라. 모르는 것을 인정하더라도 책임을 지는 좋은 방법이다.

## 소프트웨어 엔트로피

소프트웨어의 무질서도가 증가하면 '소프트웨어 부패'라고 말한다.

소프트웨어 부패에는 많은 요소들이 관여하는데, 보통 프로젝트에서의 심리학적이거나 문화적인 요소이다.

뭐가 가장 큰 문제일까?

**깨진 창문**
오랜 기간 수리하지 않고, 방치된 창문 하나는 주변에서 봤을 때 버려진 건물이라는 느낌을 준다. 그렇기 때문에 옆에 있는 다른 창문이 하나 더 깨지고, 사람들이 쓰레기를 버려도 된다고 생각하고, 벽에 낙서를 하기도 하면서 심각한 구조적 손상이 시작되는 것이다.

그렇게 되면 고치려는 의지를 넘어설 정도로 건물이 손상되고, 버려진 건물이라는 느낌은 현실이 되는 것이다.

```
깨진 창문을 내버려 두지 말라
```

'깨진 창문'(나쁜 설계, 잘못된 결정, 지저분한 코드)를 내버려 두지 말고, 발견하자마자 바로 고쳐라.

고칠 시간이 없다면 판자로 덮기라도 해라.

더 이상의 손상을 예방하기 위해 어떤 조치든 취하고, 상황을 잘 관리하고 있음을 보여줘라.

**방치는 다른 어떤 요인보다도 부패를 가속화한다**

💡깨진 창문 3가지를 골라서, 동료들과 함께 무엇이 문제이고, 고치기 위해 뭘 할 수 있는지 토론하라.

## 돌멩이 수프와 삶은 개구리

소프트웨어 참사는 대부분 너무 작아 알아채기 힘들 정도에서 시작한다.
소프트웨어 폭주는 대부분 어느 날 갑자기 일어난다.
**의욕과 팀 자체의 파괴는 종종 작은 것들의 누적에서 온다.**

```
큰 그림을 기억하라.
```

큰 그림에 늘 주의를 기울여라. 개인적으로 무엇을 하고 있는가에만 정신을 쏟지 말고, 주변에서 어떤 일이 벌어지는지 지속적으로 확인해라.

## 적당히 괜찮은 소프트웨어

'우리는 종종 뭔가 나아지게 하려다가 괜찮은 것마저 망친다.' (동의하지 않는다.)

완벽한 것을 만들어 내는 것은 불가능하다.
적당히 괜찮은 것을 만들도록 자신을 단련해야 한다.
자신은 더 생산적이게 되고, 사용자는 한층 더 행복해진다.

적당히 괜찮은이라는 말은 형편없는 코드를 뜻하는 것이 아니다. **시스템이 성공하려면 사용자의 요구사항을 충족해야 한다.** 적당히 괜찮은지를 결정하는 과정에 사용자가 참여할 기회를 줘야한다는 것을 말하는 것이다.

단순히 프로그램에 새 기능을 추가하거나 코드를 다듬기 위해서 사용자의 요구사항을 무시하는 것은 전문가답지 못한 행동이다.

사용자들에게 직접 경험할 수 있도록 한다면, 피드백을 통해 결국에는 더 나은 솔루션에 도달할 수 있을 것이다.

완벽하지 않을 수 있다. 걱정하지 마라. 완벽할 수는 없다.
훌륭한 프로그램이라면 한동안은 그대로 있도록 놓아둬라.

## 지식 포트폴리오

### 목표

매년 새로운 언어를 최소 하나는 배워라. 다른 언어는 동일한 문제를 다르게 푼다. 몇 개의 서로 다른 접근법을 알면 사고를 확장하고 판에 박힌 사고에 갇히는 걸 예방하는 데에 도움이 된다.

기술 서적을 분기마다 한 권씩 읽어라. 습관이 들면, 한 달에 한 권씩 읽어라. 현재 사용하는 기술을 일단 완전히 익혔다면, 가지치기를 해서 지금 하는 프로젝트와 관련 없는 분야까지 공부 범위를 넓혀라.

비 기술 서적도 읽어라. 컴퓨터를 사용하는 것은 사람 - 우리는 바로 이 사람들을 만족시키려고 노력하고 있다 - 이라는 것을 기억하는 게 중요하다. 방정식에서 인간이라는 변을 잊지 마라.

수업을 들어라. 근처의 대학, 혹은 시사회에서 열리는 흥미로운 강좌를 찾아보라.

지역 사용자 모임에 참여하라. 가서 가만히 듣고만 오지 말고, 적극 참여하라. 고립은 경력에 치명적일 수 있다. 여러분 회사 밖에서는 사람들이 어떤 일을 하는지 알아보라.

다른 환경에서 실험해보라. 윈도우에서만 일을 해 왔다면, 집에서는 유닉스를 갖고 놀아보라.

요즘 흐름을 놓치지 마라. 업계의 잡지와 기타 저널을 구독하라. 여러분의 현재 프로젝트와 다른 기술을 다루는 것도 몇 개 선택하라.

인터넷을 이용하라. 새 언어 혹은 기타 기술에 대해 속속들이 알고 싶은가? 다른 사람이 그에 관해 어떤 경험을 했는지, 그들이 사용하는 특별한 전문용어가 어떤 뜩인지 등을 알아내는 데는 뉴스그룹이 탁월하다.

스스로 답을 찾지 못하겠거든, 누가 답을 찾아줄 수 있을지 그 사람을 찾아라. 중단하지 마라. 다른 사람들과 이야기함으로써 개인 네트워크를 구축하는데 도움이 되기도 하고, 답을 찾는 도중에 별로 관련이 없어 보이는 문제들에 대한 해답을 찾아서 놀라는 일도 생길 것이다. 포트폴리오는 그 사이 계속 커져 간다.

## 소통하라!

아무리 잘해도, 다른 사람들과 소통할 수 없다면 궁궁적으로 아무 쓸모가 없다.

**말하고 싶은 것이 무언인지 알아라**
무엇을 말할지 미리 계획하라. 개요를 작성하라. 그리고 자문하고, 다듬어라.

**말할 타이밍을 잘 잡아라**
~~에 대해 이야기하기 좋은 타이밍인가? 라는 간단한 질문을 본인에게 하는 것만으로도 충분하다.

```
무엇을 말하는가와 어떻게 말하는가 모두 중요하다.
```

# ch.02 실용주의 접근법

개발 중에 기본적인 원리들을 유념하라.
더 좋은, 더 빠른 코드를 작성하게 될 것이다.
코드가 쉬워 보이게 만들 수도 있다.

## 좋은 설계의 핵심

기본 원칙

```
좋은 설계는 바쁜 설계보다 바꾸기 쉽다.
```

잘 설계된 코드는 바뀜으로써 사용하는 사람에게 맞춰져야 한다.
그래서 우리는 ETC 원칙을 따른다. Easier to Change.

왜 단일 책임 원칙이 유용한가?
요구사항이 바뀌더라도 모듈 하나만 바꿔서 반영할 수 있기 때문이다. === ETC

왜 네이밍이 중요한가? 네이밍을 잘하면 코드가 읽기 쉬워지고, 코드를 바꾸려면 코드를 읽어야 하기 때문이다 === ETC

**ETC는 규칙이 아니라 가치**
가치는 올바른 방향으로 결정할 수 있도록 돕는 것.

어떤 식으로 바꿔야할지 모르겠을 때는 다음 2가지를 해라.

1. 앞으로 어떤 모습으로 바뀔지 잘 모르겠을 때, 궁극적으로 '바꾸기 쉽게' 라는 길을 선택한다.

언제든 교체가 용이하도록 만드는 것이다. 교체가 용이하다면 미래에 어떤 일이 일어나도 이 코드가 발목을 잡는 일은 없을 것이다.

코드의 결합도를 낮추고, 응집도를 높여봐라.

2. 여러분의 직관을 발전시키는 기회로 삼아라.

현재 상황과 나의 선택, 변경 사항에 대한 추측을 정리하고, 코드에 이에 대한 표시를 남겨둬라.

코드를 변경해야 하는 시점이 오면 본인에게 피드백을 줄 수 있도록.

## 중복의 해악(분)

소프트웨어를 신뢰성 높게 개발하고, 개발을 이해하고 유지보수하기 쉽게 만드는 유일한 길은 우리가 DRY 원칙이라고 부르는 것을 따르는 것뿐이라 생각한다.

**DRY**

- 모든 지식은 시스템 내에서 단일하다.
- 모든 지식은 시스템 내에서 애매하지 않다.
- 모든 지식은 시스템 내에서 믿을만한 표현 양식을 가져야 한다.

```
DRY - 반복하지 마라
```

DRY를 따르지 않으면 똑같은 것이 두 군데 이상에 표현된다.
하나를 바꾸면 나머지 하나도 바꿔야된다. 귀찮다.

중복들 다루는 일반적인 전략을 알아보자.

**DRY는 코드 밖에서도**
코드에서의 중복만을 얘기하는 것이 아니다.

**문서화 중복**
함수마다 주석을 달아야 한다. 라는 것은 틀렸다!

하나의 함수의 의도가 주석과 코드 2가지로 표현되었기 때문에 중복이다.

네이밍이나 코드 구조의 부실함을 메꾸는 것이 주석이다. 함수 이름을 통해 하는 일을 알 수 있게 하고, 더 자세하게 알고 싶다면 코드를 보면 알 수 있게 만들어라.

**내부 API에서 생기는 중복**
언어나 기술에 중립적인 형식으로 내부 API를 정의할 수 있는 도구를 찾아봐라.

이 도구를 이용하여 모든 API 정의를 중앙 저장소에 넣어 두고 여러 팀이 공유할 수 있게 하면 좋다.(무슨 말이지)

**외부 API에서 생기는 중복**
오픈API같은 형식으로 문서화 하는 경우가 많아지고 있다.
이를 개인 API 도구로 불러와서 사용하면 더욱 신뢰성 있게 해당 서비스를 연동할 수 있다.

**개발자간의 중복**

발견하거나 다루기 가장 어려운 유형의 중복은 한 프로젝트에서 일하는 서로 다른 개발자 사이에서 발생한다. 전체 기능 집합이 부주의하게 중복될 수 있고, 그런 중복이 발견되지 않을 수 있다.

높은 차원의 해법으로, 깨끗한 설계와 강력하고 기술적인 프로젝트 리더, 그리고 그 설계 내에서 책임의 분배가 제대로 이해되도록 하는 것, 이런 것들로 개발자 간의 중복 문제를 다루어라. 그렇지만 모듈 차원이라면 그 문제를 알아채기란 더욱 어렵다.

우리가 느끼기에 최선책은 개발자간에 적극적이고 빈번한 소통을 장려하는 것이다. 공통의 문제를 다루기 위한 토론장을 만들어라.

```
재사용하기 쉽게 만들어라.
```

뭔가를 직접 만드는 것보다 기존의 것을 찾아내고, 또 재사용하기 쉬운 환경이다. 만약 재사용에 실패한다면 지식 중복의 위험을 각오해야 한다.

## 직교성

설계, 빌드, 테스트 그리고 확장하기에 쉬운 시스템을 만드는 데에 있어 직교성은 매우 중요한 개념이다.

직교성이란?

- 컴퓨터에서는 일종의 독립성이나, 결합도 줄이기를 의미한다.
- 하나가 바뀌어도 나머지에 어떤 영향도 주지 않으면 서로 직교한다고 할 수 있다.

**직교성의 장점**
비직교적인 시스템은 본질적으로 변화와 조정을 하기가 복잡하다. 시스템의 컴포넌트들이 고도로 상호의존적인 경우, 특정 국지정 부분만 수정하는 방법이 없다.

```
관련이 없는 코드들끼리는 서로 영향이 없도록 해라.
```

장점으로는 2가지가 있다.

**생산성 향상**

- 변화가 국소화(localize)되서 개발 시간과 테스트 시간이 줄어든다. 상대적으로 작고, 자족적인 컴포넌트를 작성하는 것이 하나의 커다란 코드 덩어리를 만드는 것보다 더 쉽다. 새로운 코드를 추가할 때 마다 기존의 코드를 계속 바꾸어야할 필요가 없다.

- 직교적인 접근법은 또한 재사용을 촉진한다. 컴포넌트들에 명확하고 잘 정의된 책임이 할당되어 있다면 애초의 구현자들이 미처 생각하지 못했던 방식으로 새로운 컴포넌트와 결합할 수 있다.

- 직교적인 컴포넌트들을 결합하는 경우 꽤 미묘한 생산성 향상이 있다. M가지 일을 하는 컴포넌트와 N가지 일을 하는 컴포넌트가 있다고 가정하자. 만약 그것들이 직교적이라면 결합했을 때 결과물은 M x N 가지 일을 한다. 직교적인 컴포넌트들을 결합함으로써 단위 노력당 더 많은 기능을 얻을 수 있다.

**리스크 감소**

- 감염된 코드는 격리된다. 어떤 모듈이 병에 걸렸다 해도 시스템의 나머지 부분으로 증상이 전파될 확률이 낮다. 그 부분만 도려내고 새롭고 건강한 놈으로 이식해 넣기도 쉽다.

- 시스템이 잘 깨어지지 않는다. 어떤 부분을 골라서 약간 바꾸고 수리해도 거기서 생기는 문제점들은 그 부분에만 한정될 것이다.

- 직교적인 시스템은 해당 컴포넌트들에 대해 테스트를 설계하고 실행하기 훨씬 쉽기 때문에, 더 많은 테스트를 하게 된다.

- 써드파티 컴포넌트로 연결되는 인터페이스들이 전체 개발의 작은 부분에 한정되기 때문에 특정 벤더나 제품, 플랫폼에 덜 종속될 것이다.

**설계**
개발자 대다수는 직교적인 시스템을 설계할 필요를 잘 안다. 시스템은 협력하는 모듈들의 집합으로 구성되어야 하고, 각 모듈은 다른 부분과 독립적인 기능을 구현해야 한다. 컴포넌트들이 레이어로 조직되기도 하는데, 각 레이어는 하나의 추상화 층을 이루게 된다. 이 레이어식 접근은 직교적 시스템을 설계하는 강력한 방법이다. 각 레이어는 자기 밑에 있는 레이어들이 제공하는 추상화만을 사용하기 때문에, 코드에 영향을 끼치지 않으면서 아래에 있는 다른 구현들을 바꾸는 높은 유연성을 얻을 수 있다.

**툴킷과 라이브러리**
외부에서 만든 라이브러리를 도입할 때, 시스템의 직교성을 해치지 않는지 확인해야 한다.

만약 객체를 저장소에 저장하는 방식이 투명하다면 직교적이다.

하지만 특별한 방식으로 객체를 생성하고 접근하면 직교적이지 않다. 이러한 세부사항을 코드로부터 분리한다면 미래에 라이브러리가 바뀌더라도 쉽게 대처가 가능하다.

**코딩**

코드의 결합도를 줄여라. 부끄럼타는 코드(shy code)를 작성하라. 즉 불필요한 어떤 것도 다른 모듈에 보여주지 않으며, 다른 모듈의 구현에 의존하지 않는 코드를 작성하라.

전역 데이터를 피하라. 코드가 전역 데이터를 참조할 때마다, 코드는 해당 데이터를 공유하는 다른 컴포넌트와 묶이게 된다.

디자인 패턴에서 소개하는 singleton pattern은 특정 클래스의 객체가 단 하나의 인스턴스만을 갖도록 보장해준다. 하지만 많은 개발자들이 싱글튼 객체를 전역 데이터의 일종으로 남용한다.

유사한 함수를 피하라. 종종 유사해 보이는 함수의 집합을 구현해야 할 떄가 있다.

중복 코드는 구조적 문제의 징후다. 디자인 패턴에서 소개한 스트래티지 패턴(strategy pattern)을 사용하여 더 나은 구현을 할 수는 없는지 고려해보기 바란다.

자신이 작성하는 코드를 항상 비판적으로 검토해 보는 습관을 기르기 바란다.

기회가 있을 때마다 코드의 구조와 직교성을 향상시키기 위해 노력하라. 이러한 프로세스를 리팩터링이라 부른다.

**테스트**
직교적으로 설계, 구현한 시스템은 테스트하기 더 쉽다. 시스템 컴포넌트 간의 상호작용이 형식화되고 제한되었기 때문에 시스템 테스트의 더 많은 부분을 각각의 모듈 수준에서 수행할 수 있기 때문이다.

이는 모듈 수준의 테스트가 통합 테스트보다 테스트케이스를 만들고 수행하기 훨씬 쉽다는 점에서 좋은 소식이라 할 수 있다.

**직교적으로 살아가기**
DRY 원리는 시스템 내부의 중복을 최소화시키고, 직교성은 시스템 컴포넌트 간의 상호의존도를 줄인다.

당연한 말이겠지만 DRY 원리로 무장하고 직교성 원리를 충실히 사용한다면 개발하고 있는 시스템이 더 유연하고, 이해하기 쉽고 또한 디버그, 테스트, 유지도 쉬워질 것이다.

## 가역성

'당신이 가진 생각이 딱 하나밖에 없다면, 그것만큼 위험한 것은 없다.'

```
최종 결정이란 없다.
```

**유연한 아키텍처**
많은 사람들이 코드를 유연하게 유지하려고 노력한다. 하지만 아키텍처, 배포, 벤더 통합 영역의 유연성에 대해서도 관심을 기울일 필요가 있다.

보통 특정 벤더 제품에 대한 의존도 등은 잘 정의하고 추상화한 인터페이스를 통해 감출 수 있다. 만약 벤더 의존적인 코드를 깨꿋하게 분리하지 않으면 어떻게 될까? 벤더 의존적인 수행문들이 코드 전반에 흩어져 있을 것이고, 이는 유지보수성, 유연성을 극도로 떨어뜨리게 된다.

누구도 미래에 대해서는 알 수 없으며, 우리라고 예외는 아니다.

**예광탄**
예광탄이 효과가 있는 까닭은 일반 탄환과 동일한 환경과 제약 조건에서 발사되고 날아가기 때문이다. 탄환이 목표물에 도달하는 시간이 짧기 때문에, 기관총 사수는 즉각적인 반응을 얻을 수 있다. 그리고 실용적인 관점에서 봐도 예광탄은 상대적으로 비용이 적게 드는 방법이다.

코딩에서도 동일한 효과를 얻으려면, 우리는 요구사항으로부터 최종 시스템의 일부 측면에까지 빨리, 눈에 보이게, 반복적으로 도달하게 해줄 무언가를 찾아야 한다.

예광탄 코드는 나중에 버리려고 만드는 것이 아니다. 그것은 계속 사용할 코드다. 예광탄 코드에도 상용 코드와 마찬가지로 모든 에러 검사, 구조화, 문서화, 자기 검사가 포함된다. 단지 예광탄 코드에는 아직 완전한 기능이 들어있지 않을 뿐이다. 하지만 시스템을 구성하는 요소를 모두 연결해 놓은 후라면 목표물에 얼마나 가까이 다가섰는지 확인할 수 있으며, 필요하다면 조정도 할 수 있다. 그렇게 해서 일단 목표물을 맞춘다면 기능을 추가하는 일은 쉽다. 예광탄 개발 방법은 점진적인 접근 방법이다.

예광탄 코드 접근 방법에는 여러 장점이 있다.

사용자들은 뭔가 작동되는 것을 일찍부터 보게 된다. 사용자들은 지금 보는 것이 아직 완성되지 않은 것임을 이해할 것이다. 이들은 기능이 없다고 실망하지 않을 것이며, 오히려 자기가 쓸 시스템에 눈에 보이는 진전이 있음을 보게 되어 매우 기뻐할 것이다. 바로 이 사용자들이 아마도 각 반복 주기마다 여러분이 얼마나 목표물에 가까이 갔는지 알려주 ㄹ사람들이 된다.

개발자들은 들어가서 일할 수 있는 구조를 얻는다. 여러분의 팀은 더 이상 무에서 많은 것을 만들어 낼 필요가 없어진다. 그러면 모든 사람의 생산성이 더 좋아지고, 일관성도 촉진된다.

통합 작업을 수행할 기반이 생긴다. 시스템의 요소들이 모두 연결된 다음에는, 코드를 추가할 수 있는 어떤 환경이 생긴다. 새로 도입된 변화가 어떤 영향을 주는지 더욱 명확하게 보이며, 상호작용들은 더 제한적이다. 그러므로 디버깅과 테스팅은 속도도 빨라지고 더 정확해질 것이다.

진전 상황에 대해 더 정확하게 감을 잡을 수 있다. 예광탄 코드 개발 방법에서 개발자들은 유스 케이스를 한 번에 하나씩 다룬다. 하나가 끝나면, 다음으로 넘어간다. 이러면 수행을 평가하기도 쉽고 사용자들에게 얼마나 진전되었는지 보여주기도 쉽다.

예광탄 코드 기법은 일이 어떻게 될지 100% 확신할 수 없는 상황에서 사용된다. 그러므로 처음 몇 번 시도 때 목표에 맞지 않더라도 놀랄 필요가 없다. 코드의 크기가 작으면 관성 역시 약하므로 빠르고 쉽게 바꿀 수 있다. 다른 어떤 방법보다 더 적은 비용과 더 빠른 속도로 애플리케이션에 대한 반응들을 모아서 새롭고 더 정확한 버전을 만들 수 있을 것이다.

프로토타입은 최종 시스템의 어떤 특정한 측면을 탐사해 보는 것이 목표다. 어떤 개념을 구현해 보려고 시도할 때 대충 끼워 맞춘 것들을 모두 버린 다음, 실험 과정에서 얻은 교훈을 바탕으로 다시 코드를 만들게 된다.

프로토타입은 나중에 버릴 수 있는 코드를 만든다. 예광탄 코드는 기능은 별로 없지만 완결된 코드이며, 최종 시스템 골격의 일부를 이룬다. 프로토타입을 예광탄이 하나라도 발사되기 전에 먼저 일어나는 정찰과 정보 수집으로 생각하면 되겠다.

## 프로토타입과 포스트잇

**프로토타이핑 대상**

- 아키텍처
- 기존 시스템에 추가할 새로운 기능
- 외부 데이터의 구조 혹은 내용
- 외부에서 가져온 도구나 컴포넌트
- 성능 문제
- 사용자 인터페이스 설계

프로토타이핑으로 조사할 대상은 위험을 수반하는 모든 것이다.

프로토타이핑의 가치는 생산한 코드에 있는 것이 아니라 이를 통해 배우는 교훈에 있다.

```
프로토타이핑으로 학습해라.
```

**프로토타입을 어떻게 사용할 것인가?**
프로토타입을 만들 때 무시해도 좋은 세부 사항

- 정확성
  적절히 가짜 데이터를 사용할 수 있다.

- 완전성
  프로토타입은 제한된 방식으로만 작동하기도 한다.

- 안전성
  오류 검사를 빼먹거나 무시할 수도 있다.

- 스타일
  주석이나 문서가 많지 않아야 한다.
  프로토타입 사용 결과는 작성할 수 있다.

## 추정

추정하는 법을 배우고, 추정능력을 계빨하여 무언가의 규모를 직관적으로 알 수 있는 정도가 되면, 추정 대상의 가능성을 가늠하는 마법과 같은 능력을 발휘할 수 있게 된다.

```
추정으로 놀람을 피하라.(미래를 예지해라)
```

**프로젝트 일정 추정하기**
'이거 구현하는 데에 얼마나 걸리나요?' 라는 PM의 질문을 받아도 걸리는 시간을 추정하는 것은 매우 어렵고, 불확실하다.

그렇기 때문에 코드 작성과 함께 일정도 주기적으로 조정하는 시간이 필요하다.

또한, 누군가에게 추정해달라는 질문을 받으면 바로 대답하지 마라. 충분히 검토하고, 단계를 밟아서 추정하면 질문을 받은 순간에 대답한 것보다 더 좋은 추정치를 얻어서 답할 수 있을 것이다.
