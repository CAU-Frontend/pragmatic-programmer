# Why?

개별 상황마다 그 상황에서 좋은 해결 방안을 고를 수 있도록. 특정 기술에 매이지 않기 위해 충분한 배경지식과 경험 필요 = 실용주의

스터디 목표 : 실용주의 개발자로 성장하기

실용주의 개발자가 되려면 

1. 어떤 일을 하면서 자신이 무엇을 하고 있는지 생각해야함
2. 개발 과정에서 내리는 모든 결정을 끊임없이 비판적으로 평가해야함

→ THINK! 생각하라

> **Tip1. 자신의 기예(craft)에 관심을 가져라.**
> 

> **Tip2. 자기 일에 대해 생각하라.**
> 

---

# 1장. 실용주의 철학

## Topic 1. 당신의 인생이다

> **Tip3. 당신에게는 agency(자율성)가 있다.**
> 

당신에게는 스스로의 행동을 직접 결정할 수 있는 힘이 있다.

- Martin Fowler ***"You can [ChangeYourOrganization](https://wiki.c2.com/?ChangeYourOrganization) or [ChangeYourOrganization](https://wiki.c2.com/?ChangeYourOrganization)."***

→ 현재 조직 내에서 일하는 방식을 바꾸는 등 조직의 변화를 꾀할 수 있다. 하지만 그게 잘 안되면 아예 다른 조직으로 옮기는 것도 한 방법이다.

기술에 뒤쳐지는 기분이 든다면 여가 시간을 쪼개서 재미있어 보이는 것을 공부하라.

→ 우선 주도적으로 행동하고 기회를 잡아라

## Topic 2. 고양이가 내 소스 코드를 삼켰어요

실용주의 프로그래머는 자신의 경력에 대해 책임을 지고, 자신의 무지나 실수를 주저 없이 인정한다.

### 팀 내 신뢰

- 창의성과 공동 작업에는 팀 내의 신뢰가 절대적으로 필요하다고 하낟.
- 서로 의지할 수 있어야한다.

### 책임지기

- 개인적으로 최선을 다하는 것이 전부가 아니다. 여러분이 통제할 수 없는 위험 요소가 있지 않은지 상황을 분석해야 한다.
- 실수를 저지르거나 잘못된 판단을 내렸다면, 정직하게 인정하고 다른 방안을 제안하도록 노력하라
- 다른 사람 혹은 다른 무언가를 비난하거나 변명을 만들어 내지 말라
    - 고양이가 내 소스 코드를 삼켰어요
    
    ![image.png](attachment:ca39bd66-0cd8-4418-a63b-4cb2d0963078:image.png)
    

> **Tip4. 어설픈 변명 말고 대안을 제시하라.**
> 

## Topic 3. 소프트웨어 엔트로피

엔트로피는 시스템 내의 ‘무질서’한 정도를 가리키는 물리학 용어다.

소프트웨어의 무질서도가 증가할 때 우리는 이를 ‘소프트웨어의 부패’라고 일컫는다.

→ ‘기술 부채’라고 부르기도 하지만 아마 갚지는.. 않을 것이다.

소프트웨어가 부패하는 데에는 많은 요소가 관여한다. 가장 중요한 것은 프로젝트에서 발생하는 심리학적 혹은 문화적 요소다.

→ ‘깨진 창문’, 방치된 창문 하나 때문에 거주자들에게 버려진 듯한 느낌이 스며든다. 이런 부정적인 생각이 팀원들 사이로 퍼져서 악순환을 만들 수 있다

> **Tip5. 깨진 창문을 내버려 두지 말라.**
> 
> - 나쁜 설계, 잘못된 결정, 혹은 형편없는 코드 등이 모두 깨진 창문이다.
> - 발견하자마자 고칠 수 없다면 주석처리, 더미 데이터와 같은 판자로 덮는 것만이라도 하라.
- 우선 망가트리지 말라, 어떤 위기가 찾아왔다고 해서 부가적인 피해를 일으키지 말라.

### 도전해 볼 것

1. 프로젝트 팀원들과 프로젝트의 깨진 창문에 대해 논의해보기
2. 창문이 깨졌을 때 먼저 목소리를 낼 수 있나? 깨진 창문이 다른 사람의 결정 혹은 경영진의 명령에 따른 결과였다면?

## Topic 4. 돌멩이 수프와 삶은 개구리

무엇을 해야 하는지, 어떻게 해야 하는지 정확히 아는 경우가 있다.

하지만 일에 착수하려고 허락을 구하는 때부터, 뭔가가 지연되거나 일이 복잡해지기 시작한다. ⇒ 시작 피로 start-up fatigue

큰 무리 없이 요구할 수 있을 만한 것을 찾아라. 그리고 그걸 잘 개발하라 → MVP

미래를 살짝이라도 보여 주면 사람들은 도와주기 위해 모여들 것이다.

> **Tip6. 변화의 촉매가 되라.**
> 

마을 사람들은 돌멩이에 대해서 생각하느라 세상의 다른 일들에 대해서는 까맣게 잊어버렸다.

소프트웨어 참사는 대부분 너무 작아 알아채기 힘들 정도의 문제에서 시작되고, 프로젝트는 대부분 어느 날 갑자기 폭주한다.

> **Tip7. 큰 그림을 기억하라**
> 

끓는 물속에 개구리를 넣으면 튀어오르지만, 서서히 물을 덥히면 개구리는 삶아질 것이다.

큰 그림에 늘 주의를 기울여라. 당장 하고 있는 일에만 정신을 쏟지 말고, 주변에서 무슨 일이 벌어지는 지 늘 살펴보라.

### 도전해 볼 것

1. 속임을 통해서 긍정적인 촉매가 된 돌멩이 수프냐 개구리에게 나쁜 일이 생기는 개구리 수프인가
2. 주변을 살피고 의식하는 습관을 들여라

## Topic 5. 적당히 괜찮은 소프트웨어

적당히 괜찮은 소프트웨어를 만들도록 자신을 단련할 수 있다.

‘적당히 괜찮은’이라는 표현은 형편없는 코드를 의미하지 않는다. 시스템이 성공하려면 사용자의 요구사항을 충복해야 한다.

→ 적당히 괜찮게 사용자의 요구를 충족하는지 결정하는 과정에 **사용자가 참여할 기회**를 가져야 한다는 것이다.

### 타협 과정에서 사용자를 참여시켜라

> **Tip8. 품질을 요구 사항으로 만들어라.**
> 

오늘의 훌륭한 소프트웨어는 많은 경우 환상에 불과한 내일의 완벽한 소프트웨어보다 낫다.

사용자에게 뭔가 직접 만져볼 수 있는 것을 일찍 준다면, 피드백을 통해 종국에는 더 나은 해결책에 도달할 수 있을 것이다.

### 멈춰야 할 때를 알라

완벽하게 훌륭한 프로그램을 과도하게 장식하거나 지나칠 정도로 다듬느라 망치지 말라. 완벽해지기란 불가능하다.

### 도전해 볼 것

- 버저닝을 잘해야겠다… how?
- 결합도가 높고 한 덩어리로 된 모놀리식 소프트웨어 블록을 필요한 품질 수준으로 만들기 vs 매우 느슨하게 결함된 모듈과 같은 설계된 시스템을 만드는 것 → 무엇이 더 오래걸릴까?
- 기능 블로트 feature bloat, 소프트웨어가 유저가 쓰는 기능에 비해 훨씬 더 많은 기능을 가지고 있는데, 기능이 많은 만큼 버그나 보안 취약점이 생길 가능성도 높은 것

## Topic 6. 지식 포트폴리오

우리는 프로그래머들이 컴퓨터, 애플리케이션 도메인 등에 대해 알고 있는 모든 사실과 경험을 그들의 ‘지식 포트폴리오’로 생각해보길 좋아한다.

### 포트폴리오 만들기

#### 주기적인 투자

지식 포트폴리오에 소량으로라도 주기적으로 투자해야 한다.

#### 다각화

기본적으로 현재 작업에 사용하는 기술에 관해서는 속속들이 알아야 한다.

하지만 거기서 멈추지 말라. 더 많은 기술에 익숙하다면 변화에 더 잘 적응할 수 있을 것이다. 기술 외의 분야도 포함.

#### 리스크 관리

기술 달걀을 한 바구니에 담지 말라.

#### 싸게 사서 비싸게 팔기

새롭게 떠오르는 기술이 인기를 끌기 전에 미리 알고 학습하는 것

#### 검토 및 재조정

동적인 산업이기 때문에 기술을 검토하고 재조정하기. 한순간에 찬밥이 될 수 있다.

> **Tip9. 지식 포트폴리오에 주기적으로 투자하라**
> 

### 목표

1. 매년 새로운 언어를 최소 하나는 배워라
2. 기술 서적을 한 달에 한 권씩 읽어라
3. 기술 서적이 아닌 책도 읽어라
4. 수업을 들어라
5. 지역 사용자 단체나 모임에 참여하라
6. 다른 환경에서 실험해 보라
7. 요즘 흐름을 놓치지 말라

투자를 지속하는 것이 중요하다. 한 기술의 새로운 용어나 기능에 익숙해지면 다음으로 나아가라.

학습 과정에서 사고가 확장된다. 새로이 배운 교훈을 현재 프로젝트에 적용하도록 노력하라.

### 학습의 기회

답을 찾기 위한 개인적인 도전으로 생각하라. 이 모든 독서와 연구는 시간이 걸리고 시간은 늘 부족한 자원이다. 그래서 미리 계획해야만 한다.

### 비판적 사고

여러분의 포트폴리오에 있는 지식을 정확히 유지할 수 있도록 하고 업체나 매체의 과대광고에 흔들리지 않아야 함을 명심하라.

> **Tip10. 읽고 듣는 것을 비판적으로 분석하라.**
> 
- 왜냐고 다섯번 묻기
- 누구에게 이익이 되나?
- 어떤 맥락인가?
- 언제 혹은 어디서 효과가 있을까?
- 왜 이것이 문제인가?

## Topic 7 소통하라!

뭘 가졌느냐 만이 아니라 그걸 어떻게 포장하느냐도 중요하다.

개발자로서 우리는 여러 입장에서 소통해야한다. 최종 사용자와도, 기계와도, 다음 세대의 개발자들에게도…

> **Tip11. 한국어든 영어든 하나의 프로그래밍 언어일 뿐이다.**
> 
- 청중을 알라
    - 전달하려는 내용을 제대로 전달하고 있는 경우에만 소통하고 있다고 할 수 있다. 그렇게 하기 위해서는 청중의 요구와 관심, 능력을 이해할 필요가 있다.
    - 피드백을 모아라. 그저 질문을 기다리지 말고 먼저 물어보라.
- 말하고 싶은게 무언지 알라
    - 무엇을 말할지 미리 계획하라. 개요를 작성하라. 그리고 자문하라.
    - “이렇게 하면 내가 표현하고 싶은 것을 듣는 사람에게 통하는 방법으로 잘 전달할 수 있나?” 그렇게 될 때까지 다듬어라.
- 때를 골라라
    - 말하는 내용뿐만 아니라 말하는 시점도 적절하게 하라.
- 스타일을 골라라
    - 전하는 스타일을 청중에 어울리도록 조정하라.
- 멋져 보이게 하라
    - 너무 많은 개발자가 문서를 만들 때 내용에만 집중한다.
- 청중을 참여시켜라
- 경청하라
- 응답하라
    - 늘 사람들에게 응답해 주면 때때로 저지르는 실수에 대해 훨씬 더 관대해질 것이고 여러분이 그 사항을 아직 잊지 않았다고 느끼게 할 것이다.
    
    > **Tip12. 무엇을 말하는가와 어떻게 말하는가는 모두 중요하다.**
    > 
- 문서화
    - 실용주의 프로그래머는 문서화를 전체 개발 프로세스의 필요 불가결한 부분으로 받아들인다.
    
    > **Tip13. 문서를 애초부터 포함하고, 나중에 집어넣으려고 하지 말라.**
    > 
    

### 도전해 볼 것

- 의사소통 관련 책 추천: <맨먼스 미신>, <피플웨어>, <파충류의 뇌>

---

# 2장. 실용주의 접근법

## Topic 8. 좋은 설계의 핵심

> **Tip14. 좋은 설계는 나쁜 설계보다 바꾸기 쉽다.**
> 

잘 설계된 코드는 바뀜으로써 사용하는 사람에게 맞춰져야 한다.

그래서 우리는 ETC 원칙을 따른다. 바꾸기 더 쉽게 Easier to Change. 

- 결합도를 줄이면 → 관심사 분리 → 각각이 바꾸기 쉬워짐
- 단일 책임 원칙 SRP → 요구 사항이 바뀌더라도 모듈 하나만 바꿔서 반영 가능
- 왜 이름짓기가 중요? → 코드 읽기 쉬워짐 → 코드를 바꾸려면 코드를 읽어야 함

### ETC는 규칙이 아닌 가치

가치는 결정을 내리게 도움을 주는 것. 바꾸기 쉬운가를 고민하는 것..의식적으로 생각하려고 노력해야한다.

코드의 결합도를 낮추고 응집도를 높여라. 엔지니어링 일지에 선택 그리고 변경사항에 대한 추측을 정리해 둬라. 그리고 소스코드에 이에 대한 표시를 남겨둬라.

### 도전해 볼 것

- 일상적으로 사용하는 설계 원칙: MVC, MVVM 등 모두 변경이 쉽도록 단계별 역할 분리 ETC
- 개방폐쇄원칙? 확장에는 열려있고 수정에는 닫혀있기

## Topic 9. DRY: 중복의 해악

지식은 고정적이지 않다. 지식은 변화한다. 프로그래머는 늘 유지 보수 모드에 있다. 우리의 이해는 날마다 바뀐다.

유지보수는 별개의 활동이 아니며 전체 개발 과정의 일상적인 부분이다.

유지보수를 하려면 애플리케이션에 표현되어 있는 지식을 찾아내고 또 바꿔야 한다.

문제는 명세와 프로세스, 개발하는 프로그램 안에 지식을 중복해서 넣기 쉽다는 것이다 → 유지보수가 어려워진다.

소프트웨어를 신뢰성 높게 개발하는 유일한 길, 개발을 이해하고 유지 보수하기 쉽게 만드는 유일한 길은 DRY 원칙을 따르는 것이다.

- DRY 원칙 : 모든 지식은 시스템 내에서 단 한 번만, 애매하지 않고, 권위 있게 표현되어야 한다.

> **Tip15. DRY: 반복하지 말라 Don’t Repeat Yourself**
> 

### DRY는 코드 밖에서도

DRY는 지식의 중복, 의도의 중복에 대한 것이다. 경우에 따라서는 중복 표현이 두 가지 완전히 다른 방식으로 이루어질 수도 있다. 

- 코드의 어떤 측면을 하나 바꿔야 할 때 여러 곳을 바꾸고 있나?
- 코드도 바꾸고 문서도 바꾸는가?
- 데이터베이스 스키마와 스키마를 담고 있는 구조 등도?

### 코드의 중복

```ruby
def print_balance(account)
	printf "Debits: %10.2f\n", account.debits
	printf "Credits: %10.2f\n", account.credits
	if account.fees < 0
		printf "Fees: %10.2f-\n", -account.fees
	else
		printf "Fees: %10.2f\n", account.fees
	end
	printf "           -----------\n"
	if account.balance < 0
		printf "Balance: %10.2f-\n", account.balance
	else
		printf "Balance: %10.2f\n", account.balance
	end
end
```

→ 음수를 다루는 부분의 방식, 지식이 중복된다.

### 모든 코드 중복이 지식의 중복은 아니다

```python
def validate_age(value):
	validate_type(value, :integer)
	validate_min_integer(value, 1)
	
def validate_quantity(value):
	validate_type(value, :integer)
	validate_min_integer(value, 1)
```

함수의 내용이 동일하기 때문에 DRY 위반? ⇒ X, 코드는 동일하지만 두 함수가 표현하는 지식은 다르다. 각각 서로 다른 것을 검증하고 있지만 우연히 규칙이 같은 것뿐이다.

### 문서화 중복

모든 함수에 주석 추가? → 클라이언트의 요구가 바뀌면 우리는 함수 뿐만 아니라 주석도 고쳐야함.

주석이 코드에 어떤 가치를 더하는지 생각하기. 코드 구조의 부실함을 메꾸기만 하는건 아닌지..

함수 이름을 자세하게 쓰자 DRY

### 데이터의 DRY 위반

자료 구조는 지식을 표현한다.

```java
class Line {
	Point start;
	Point end;
	double length;
}
```

start와 end를 알면 length는 자동으로 결정된다. 따라서 길이는 계산되는 필드로 만드는 편이 낫다.

비용이 많이 드는 연산을 여러번 수행하지 않기위해 그냥 저장하면 안되나? → 대신 바깥 세상에 DRY 원칙 위배를 노출하지 말자

```java
class Line {
	private Point start;
	private Point end;
	private double length;
	
	public Lint(Point start, Point end){
		this.start = start;
		this.end = end;
		calculateLength();
	}
	
	void setStart(Point p) {this.start = p; calculateLength();}
	void setEnd(Point p) {this.end = p; calculateLength();}
	
	Point getStart() {return start;}
	Point getEnd() {return end;}
	
	double getLength() {return length;}
	
	private void calculateLength() {
		this.length = start.distanceTo(end);
	}
}
```

모듈이 자료구조를 노출하면 언제나 모듈의 구현과 자료구조를 사용하는 코드 사이에 결합이 생긴다. so 가능하다면 속성을 읽고 쓸 때 접근자 함수를 사용하자. 단일 접근 원칙.

### 표현상의 중복

코드가 바깥 세상과 연결 될 때 api, 스키마, 에러 코드, 응답 구조 등…  연결을 표현하는 지식을 여러분의 코드와 외부의 존재 양쪽이 모두 알아야 하기 때문에 중복 발생.

→ 아예 피할 수는 없지만 완화는 가능

- 내부 api에서 생기는 중복
    - 언어나 기술에 중립적인 형식으로 내부 api를 정의할 수 있는 도구를 찾아보기 swagger, thrift, protocol buffer → 여러팀이 공유할 수 있도록
- 외부 api에서 생기는 중복
    - openAPI와 같은 형식으로 문서화하는 경우가 많아짐. api 명세를 여러분의 api 도구로 불러와서 사용하기
- 데이터 저장소와의 중복
    - 데이터 저장소의 스키마 분석 기능 활용하기.

### 개발자 간의 중복

의사소통을 잘하는 튼튼하고 유대가 돈독한 팀을 만들어야 한다… 데일리 스크럼. 슬랙, 코드리뷰

> **Tip16. 재사용하기 쉽게 만들어라.**
> 

뭔가를 직접 만드는 것보다 기존의 것을 찾아내고 재사용하기 쉬운 환경을 조성해야 한다. 

## Topic 10. 직교성

직교성 orthogonality은 설계외 빌드, 테스트, 확장이 쉬운 시스템을 만드는데 있어 매우 중요한 개념

### 직교성이란

두 직선이 직각으로 만나는 경우 ‘직교’한다. 두 선은 독립적이다. 컴퓨터 과학에서 이 용어는 일종의 독립성이나 결합도 줄이기를 의미한다. 하나가 바뀌어도 나머지에 어떤 영향을 주지 않으면 서로 직교한다고 할 수 있다.

### 직교성의 장점

비직교적인 시스템은 본질적으로 변경과 조정이 더 복잡하다.

> **Tip17. 관련 없는 것들 간에 서로 영향이 없도록 하라.**
> 

자족적인 컴포넌트, 즉 단일하고 잘 정의된 목적을 가진 독립적이 컴포넌트가 필요. 컴포넌트들이 각기 격리되어 있으면 하나를 바꿀 때 나머지 것들을 걱정하지 않아도 된다.

- 생산성 향상: 변화를 국소화해서 개발 시간과 테스트 시간이 줄어든다. 재사용 촉진, 직교적인 컴포넌트들을 결합해 시너지 발생
- 리스크 감소: 모든 개발 작업에 존재할 수 밖에 없는 위험의 크기를 감소시켜준다.

### 설계

계층 구조는 직교적 시스템을 설계하는 강혁한 방법이다. 각 계층은 자기 바로 밑에 있는 계층이 제공하는 추상화만을 사용하기 때문.. → 계층형 설계!

### 툴킷과 라이브러리

툴킷이나 라이브러리를 도입할 때에는 심지어 같은 팀의 다른 멤버가 작성한 것이더라고 이것이 여러분의 코드에 수용해서는 안 될 변화를 강요하지 않는지 검토해보라. 라이브러리를 활용하는 세부사항들을 코드로부터 분리한다면 미래에 라이브러리가 바뀌더라도 쉽게 대처 가능

### 코딩

- 코드의 결합도를 줄여라
    - 부끄럼쟁이 코드를 작성하라. 불필요한 것은 다른 모듈에 보여 주지 않으며, 다른 모듈의 구현에 의존하지 않는 코드를 작성하라
- 전역 데이터를 피하라
    - 코드가 전역 데이터를 참조할 때마다 코드는 해당 데이터를 공유하는 다른 컴포넌트와 묶이게 된다.
    - 싱글턴 객체를 일종의 전역 데이터로 남용한다. 싱글턴을 사용할 때는 주의를 기울여라. 불필요한 결합을 만들 수 있다.
- 유사한 함수를 피하라
    - 아마도 시작과 끝에서는 동일한 코드를 사용하지만, 중간의 알고리즘이 다를 것이다. 중복 코드는 구조에 문제가 있다는 징후이다.

⇒ 코드를 비판적으로 바라보고, 코드의 구조와 직교성을 개선하기 위해 노력하라. 리팩터링

### 테스트

직교적으로 설계하고 구현한 시스템은 테스트하기 더 쉽다. 단위 테스트를 작성하는 행위 자체가 직교성을 테스트해 볼 수 있는 기회이다. 단위 테스트를 빌드하고 실행하기 위해 가져와야할 작업이 많지는 않은지?

### 문서화

정말 직교적인 문서라면 내용 변화 없이 모양새를 완전히 바꿀 수 있다.

마크다운과 같은 마크업 체계 - 내용을 쓸 때는 내용에만 집중하고, 예쁘게 꾸미는 것은 다른 도구에 맡길 수 있다.

## Topic 11. 가역성

가역성(可逆性)은 반응이나 변화가 원상으로 돌아올 수 있는지 여부를 뜻한다.

> **Tip18. 최종 결정이란 없다.**
> 

결정이 바뀌지 않을 것이라 가정하고서 발생할지도 모를 우연한 사건에 대비하지 않는 데에서 실수가 나온다.

### 유연한 아키텍처

아키텍처가 변덕스러운 환경에서 할 수 있는 건 바꾸기 쉽게 만드는 것.

> **Tip19. 유행을 좇지 말라**
> 

누구도 어떤 미래가 펼쳐질지 알 수 없으며, 우리 분야는 특히 더 그렇다.

## Topic 12. 예광탄

탄자 뒷부분에 불빛을 내는 예광제가 들어있어 날아가는 궤적이 보이는 총알 또는 포탄

사람들이 힘든 계산보다 예광탄을 좋아한다는 사실은 놀랄 일이 아니다. 예광탄은 반응도 즉각적이고, 실제 탄환과 동일한 환경 조건에서 날아가기 때문에 외부의 영향도 최소화된다. 

실용주의 프로그래머는 소프트웨어 판 예광탄을 선호한다.

### 어둠 속에서 빛을 내는 코드

> **Tip20. 목표물을 찾기 위해 예광탄을 써라.**
> 

예광탄 코드는 나중에 버리려고 만드는 것이 아니다. 그것은 계속 사용할 코드다. 예광탄 코드에도 상용 코드와 마찬가지로 모든 에러 검사, 구조화, 문서화, 자기 검사가 포함된다.

예광탄 개발 방법은 프로젝트는 결코 끝나지 않는다는 관념과도 일맥상통한다. 변화에 대한 요구와 추가할 기능은 언제나 계속 생기기 마련이다. 예광탄 개발 방법은 점진적인 접근이다.

진전 상황에 대해 더 정확하게 감을 잡을 수 있다. 예광탄 코드 개발 방법에서 개발자들은 유스 케이스를 한번에 하나씩 다룬다. 

### 예광탄이 언제나 목표물을 맞히는 것은 아니다

예광탄은 지금 맞추고 있는 것이 무엇인지 보여준다. 그러나 그것이 꼭 목표물이라는 보장은 없다. 그럴 경우 목표물이 맞을 때까지 조준을 옮겨야 한다.

### 예광탄 코드 대 프로토타이핑

예광탄 코드 접근 방법은 … 애플리케이션이 전체적으로 어떻게 연결되는지를 알고 싶다. 사용자들에게 실제로 애플리케이션의 요소들이 어떻게 상호작용하는지 보이고 싶고, 개발자들이게는 코드를 붙일 아키텍처적 골격을 제시하고 싶다.

**프로토타입은 나중에 버릴 수 있는 코드를 만든다. 예광탄 코드는 기능은 별로 없지만 완결된 코드이며, 최종 시스템 골격의 일부를 이룬다.** 

⇒ 맞춰가면서 오차를 줄여나가는 부분이 애자일 방법론과 비슷한듯

## Topic 13. 프로토타입과 포스트잇

> **Tip21. 프로토타이핑으로 학습하라.**
> 

실제 제품을 개발하기 전에 특정 측면이 걱정된다면 프로토타입을 만들어서 확인해보자. 알고리즘의 성능이 괜찮을지, 아키텍처 구성이 괜찮을지, 외부 데이터의 구조를 적용할 수 있을지 등등 다양한 측면에서 활용이 가능하다.

프로토타입은 코드로 만들 수 도 있고 단순히 포스트잇을 붙여가면서 만들수 도 있다. 증명하고자 하는 특정 측면에 적합한 도구를 사용하자. 

### 프로토타입의 대상

프로토타입의 대상은 위험을 수반하는 모든 것이다. 또한 이전에 해본 적이 없는 것, 최종 시스템에 매우 중요한 것 등이 프로토타입의 대상이 된다.

전체적으로 시스템이 어떻게 동작할지에 대한 감을 잡는 것이다.

생산한 코드가 아닌 이를 통해 배우는 교훈, 전체적으로 시스템이 어떻게 동작할지 아는 것

### 프로토타입을 어떻게 사용할 것인가?

무시해도 될 세부사항

- 정확성: 적절히 더미 데이터 사용하기
- 완전성: 제한된 방식으로만 작동하기도 함
- 안전성: 오류 검사를 빼먹거나 아예 무시할 수도 있다.
- 스타일: 프로토타입 코드에는 주석이나 문서가 많지 않아야 한다. 다만 프로토타입을 사용해 본 결과를 문서로 많이 작성할 수는 있다.

### 아키텍처 프로토타이핑

프로토타입에서 규명할 내용

- 주요 영역의 책임이 잘 정의되었고 적절한가?
- 결합도는 최소화 했는가?
- 중복이 발생할만한 곳이 있는가?
- 각 모듈이 실행 중에 필요한 데이터에 접근할 수 있는 경로를 갖고 있는가? 모듈에 데이터가 필요한 시점에 데이터 접근이 가능한가?

### 프로토타입 코드를 사용하지 않도록 하려면?

프로토타입을 만들때 중요한 점은 증명을 한 후에는 **프로토타입을 버려야한다는 것**이다. 실제 제품에 사용하는 것이 아니라 테스트 및 증명을 위해 사용해야 한다. 실제 제품에 사용하고 싶으면 예광탄을 사용하자.

*나무 자동차를 타고 러시아워에 운전할 수는 없다.*

## Topic 14. 도메인 언어

> **Tip22. 문제 도메인에 가깝게 프로그래밍하라.**
> 

*언어의 한계가 곧 자기 세계의 한계다 - 루트비히 비트겐슈타인*

실용주의 프로그래머라면 어떤 경우에는 한 차원 더 나아가서 그 도메인의 실제 어휘와 문법, 의미론을-즉, 그 도메인의 언어를-사용해서 프로그래밍할 수도 있다.

사용자들이 정리가 잘 된 진술을 많이 해준다면, 여러분은 그들이 원하는 내용을 정확히 표현하는, 그 앱 도메인에 맞춰진 소형 언어를 만들 . 수있다.

## Topic 15. 추정

> **Tip23. 추정으로 놀람을 피하라.**
> 

추정하는 법을 배우고 추정 능력을 계발하여 무언가의 규모를 직관적으로 짚을 정도가 되면, 추정 대상의 가능성을 가늠할 수 있다.

전달하려는 정확도를 고려하여 답변의 단위를 선택하라

### 추정치는 어디에서 나오는가?

모든 추정치는 문제의 모델에 기반한다. 

1. 무엇을 묻고 있는지 이해하라
    1. 추정하기 전에 미리 어떤 조건이 있을지 생각하는 습관을 길러야 한다.
2. 시스템의 모델을 만들어라
    1. 기본적인 것만 갖춘 개략적인 모델을 만들어보라. 모델을 만드는 과정에서 이전에는 표면에 명확히 드러나지 않았던 숨겨진 패턴과 프로세스를 발견하는 경우도 많다.
3. 모델을 컴포넌트로 나눠라
    1. 다 만든 모델은 컴포넌트로 분해할 수 있다. 컴포넌트들이 어떻게 상호 작용하는지를 수식으로 기술해야 한다.
4. 각 매개변수에 값을 할당하라
    1. 매개 변수를 찾아냈다면 값을 할당한다.
    2. 결과에 가장 큰 영향을 미치는 매개변수를 찾아서 매개변수의 값을 최대한 정확하게 산출한다.
5. 답을 계산하라.
    1. 주요 매개 변수들의 값을 변경시켜 가면서 여러 번 계산해보고, 이 가운데 어떤 것이 모델에 잘들어맞는지 찾아내라
6. 여러분의 추정 실력을 기록하라

### 프로젝트 일정 추정하기

초기 기능의 구현과 테스트를 마친 후, 이를 첫 번째 이터레이션의 끝으로 삼아라. 이 주기의 경험을 바탕으로 이터레이션의 수와 각 이터레이션에서 무엇을 할지에 대한 처음의 추측을 다듬을 수 있을 것이다.

> **Tip24. 코드와 함께 일정도 반복하며 조정하라.**
>
