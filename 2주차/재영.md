# 3장 - 기본 도구

**많은 신참 프로그래머가 특정 통합 개발환경 같은 강력한 도구 하나만 고집하는 실수를 저지른다**

... 내 얘기긴한데, 실수인지는 아직 잘 모르겠다. 불편한 점이 없기 때문이다.

- IDE가 갖는 한계를 넘어설 수 있어야 한다.
- 유일한 방법은 기본 도구들을 언제나 곧바로 사용할 수 있도록 예리하게 유지하는 것이다.

도구들의 사용법을 배우는 데에 시간을 투자하라. 언젠가는 별다른 자각 없이도 손가락이 키보드 위를 움직이면서 텍스트를 조작하고 있을 것이니라.

## Topic 16 - 일반 텍스트의 힘

일반 텍스트

- 인쇄 가능한 문자로 이루어지고, 정보를 저낟ㄹ하기에 적합한 형식을 갖추어야 한다.

**지식을 일반 텍스트로 저장하라**

일반 텍스트가 널리 쓰이는 이유

- 지원 중단에 대한 보험
- 기존 도구의 활용
- 더 쉬운 테스트

### 지원 중단에 대한 보험

사람이 읽을 수 있는 형태의 데이터와 그 자체만으로 의미가 드러나는 데이터는 어떤 형태의 데이터보다 오래 살아남는다.

사람이 읽을 수 있는 것과 사람이 이해할 수 있는 것에는 차이가 있다.

### 기존 도구의 활용

버전관리 시스템에서 에디터, 명령 줄 도구에 이르기까지 컴퓨터 세계의 거의 모든 도구는 일반 텍스트를 다룰 수 있다.

### 더 쉬운 테스트

테스트에 사용할 데이터를 일반 텍스트로 표현하면 특별한 도구를 만들 필요 없이 간단하게 테스트 데이터를 추가하거나 수정할 수 있다.

... 일반 텍스트가 아닌 다른 걸로 표현하면 어렵게 테스트를 해야된다는 예시가 부족해서 아쉽다.

### 최소 공통분모

거칠고 위험한 인터넷 세상을 여행하는 미래 시대에도 텍스트 파일은 어디에나 존재한다.

하나의 공통 표준을 사용해서 소통을 해야 하는데, 일반 텍스트가 바로 그 표준이다.

## 셸 가지고 놀기

텍스트 파일을 다루는 프로그래머에겐 명령어 셸이 작업대다.

GUI를 써도 똑같은거 아닌가?
아니다.

GUI의 단점은 보이는 것이 얻는 전부이다라는 점이다.
GUI 환경의 기능은 일반적으로 설계자가 의도한 범위를 넘어설 수 없다.

하지만 우리는 그 모델 이상이 자주 필요하다.
... 언제 필요한지 잘 와닿지 않는다.

작업을 하는 도구의 사용 범위는 보통 그 도구가 사용되리라고 예상되는 작업에 한정된다.

**명령어 셸의 힘을 사용하라**

지금은 익숙하지 않을 수 있다.
명령어 셸을 가지고 놀다 보면 오르는 생산성을 확인할 수 있을 것이다.

### 자신만의 셸

개발자도 셸을 자신에게 맞추어야 한다.
보통 설정하는 사항은

1. 색깔 조합 설정
2. 프롬프트 설정
3. 별칭과 셸 함수.
4. 명령어 자동 완성

셸 안에서 많은 시간을 보내게 될 것이다. 소라게처럼 셸을 내 집으로 만들자.

### 파워 에디팅

텍스트를 손쉽게 조작할 수 있어야 한다.

에디터를 몇 개 사용해도 상관없다.
다만 각 에디터에 익숙해져야 한다.

**에디터를 유창하게 쓸 수 있게 하라**

어떤 것이 유창한 것인가?

1. 텍스트를 편집할 때 문자, 단어, 줄, 문단 단위로 커서를 이동하거나 내용을 선택하라
2. 코드를 편집할 때 반대쪽 괄호로 이동하거나, 함수, 모듈, 등 다양한 문법 단위로 커서를 이동하라.
3. 변경한 코드의 들여쓰기를 자동으로 맞춰라
4. 여러 줄의 코드를 명령 하나로 주석 처리했다가 다시 주석을 해제하라.
5. 실행 취소를 여러 번 했다가 취소한 명령을 재실행 기능으로 다시 수행하라.
6. 에디터 창을 여러 구역으로 쪼개라. 그리고 구역 사이를 이동하라.
7. 특정 줄 번호로 이동하라.
   등등

이 것들을 마우스 없이 할 수 있는가??????
에디터 자체에서 불가능한거라면 에디터를 바꿀 필요가 있다.

### 유창해지기

명령어를 다 외울 필요는 없다.
삶이 편해지는 명령어만 배워라.
무언가 같은 일을 반복할 때, '분명 더 나은 방법이 있을텐데'라고 생각하는 습관을 들였다.

유용한 기능을 찾았다면 반복해서 몸이 기억하도록 해라.

### 에디터 성장시키기

에디터에 한계에 봉착하면 확장 기능을 추가할 생각도 해라.

필요한 기능이 없다면 누군가 해결책을 만들어 놓았을 것이다.

## 버전 관리

버전 관리란 거대한 Crtl+Z 이다.

하지만 그것이 전부가 아니다. 더 살펴보자.

### 소스 코드부터 시작

버그 추적이나, 감사, 성능 관리, 품질 관리에 유용하다.

특정 릴리스를 찾을 수도 있고, 장기간 보관에도 탁월하다.

... Git을 말하는거구나

**언제나 버전 관리 시스템을 사용하라**

어떤 작업이라도 모든 것을 버전 관리 아래에 둬라.
우리의 일상적인 작업은 저장소에 안전하게 보관된다.

... 오 그렇네, 전화번호부 조차도 버전 관리에 가깝다.

### 브랜치 사용하기

개발 중인 내용을 외딴 섬처럼 따로 분리해서 격리하는 '브랜치'가 있다.

... git switch -c feat/login (#2)

브랜치는 프로젝트의 작은 복사본이라고 할 수 있다.

프로젝트에서 버전 관리 시스템을 사용하고, 업무 흐름에서 문제가 생기면 해결책을 찾아봐라. 경험이 좀 더 쌓이면 본인의 사용 방식을 검토하고 조정하는 것도 잊지 마라.

### 프로젝트 허브로서의 버전 관리

버전 관리의 가치는 저장소를 어떻게 관리하느냐에서 결정된다.

저장소는 외부 서비스 이용을 추천한다. 다음과 같은 기능이 필요하다.

1. 확실한 보안과 권한 관리
2. 직관적인 UI
3. 명령 줄에서도 모든 작업 수행 가능
4. 자동화된 빌드와 테스트
5. 브랜치 병합 지원
   등등

## 디버깅

시스템에서 말하는 버그는 먼 옛날 컴퓨터 기기에 걸린 '나방'을 시스템에 BUG가 있다고 보고했던 경우에서 유래된 말이다.
... ㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋ

아무도 완벽한 소프트웨어를 작성하지 못하므로 하루 대부분을 디버깅으로 보내게 될 것이다. 버그를 찾아내는 일반적인 전략을 알아보도록 하자.

### 디버깅의 심리

**비난 대신 문제를 해결하라**

버그가 누구의 잘못인지는 중요하지 않다. 어쨌거나 우리가 해결해야 한다.

### 디버깅 사고방식

**가장 속이기 쉬운 사람은 자기 자신이다.**

디버깅 하기 전에 편안한 상태를 만들어라.

**당황하지 마라**
... ㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋ

한걸음 뒤에서 버그의 원인이 무엇인지 생각하는 것이 중요하다.

그리고 그럴리가 없다는 말을 하지마라. 그런 생각의 흐름에 신경 세포 하나도 낭비하면 안된다. 왜냐하면 이미 그런 일이 일어났기 때문이다.

... ㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋ나다 ㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋ

표면에 보이는 증상만 고치려는 생각을 버려라.

근본적인 원인을 찾아서 해결하는 것이 핵심이다.

### 실마리 찾기

버그를 살펴보기 전에 코드가 경고 없이 깨끗하게 빌드가 되는지 먼저 확인해라.

- 처음에 받은 자료 이상을 얻기 위해서 버그를 보고한 사용자를 인터뷰할 필요도 있다.
- 경제 조건과 실제 최종 사용자의 사용 패턴 모두를 철저히 테스트해야 한다.

### 디버깅 전략

- 버그 재현하기

**코드를 고치기 전에 실패하는 테스트부터 작성해라**

버그가 발생하는 상황을 다른 것들로부터 분리하다 보면 어떻게 고쳐야 할지 감이 잡힌다.

**오류 메시지를 좀 읽어라**
... 넵

- 이상한 결과

프로그램이 죽는 것이 아니라 결과가 이상한 상황이 오면 어쩔까?

디버거에 잘못된 값이 나타나는지 확인하라.
이진 분할이 도움이 될 때도 있다.

- 입력값에 따라 바뀜

특정 데이터가 들어오면 죽는 경우가 있다. 데이터 세트를 복사한 다음 개발 환경에서 실행시킨 앱에 입력해서 여전히 프로그램이 죽는지 확인하라. 죽는다면 이진 분할을 이용해서 정확히 어떤 값이 범인인지 찾아내라

- 릴리스 사이에서 발생한 문제

어떤 변경 사항 때문에 버그가 발생했는지 알 수 있으면 좋다.
이진 분할이 등장할 시간이다.

### 이진 분할

배열에서 특정한 값을 찾을 때 하나씩 차례대로 값을 확인하면 느리다.

분할 정복 방식을 사용하면 더 빠르다.
배열의 중앙값을 고르고, 이를 기준으로 배열을 2개로 쪼갠다.

원하는 값이 중앙값보다 작으면 앞배열, 아니면 뒷배열에 존재하는 것이다.

그다음 해당하는 배열에서 또 중앙값을 찾아 쪼개면서 반복하면 금방 찾을 수 있다.

- 로깅과 트레이싱

디버거는 일반적으로 프로그램의 현재 상태에 주목한다.
그 이상이 필요할 수도 있다.

시간에 따라 프로그램이나 데이터 구조의 상태가 변하는 것을 관찰해야 할 때도 있기 때문이다.

트레이싱 구문은 '여기까지 도달'이나 'x값 = 2' 같이 화면 혹은 파일에 출력하는 작은 진단용 메시지를 일컫는다.

트레이싱은 여러 프로세스가 동시에 작동하는 경우, 실시간 시스템, 이벤트 기반 앱 등, 시간 자체가 중요한 요소가 되는 시스템에서 이루 말할 수 없이 소중하다.

호출 트리에서 내려갈 때마다 트레이싱 구문을 추가할 수 있다.

우리의 실수일 수 있는 일을 시스템의 문제라고 탓하기 시작하면 우리는 그 사건을 떠올리도록 'select가 망가졌어'라는 표현을 사용한다.

**'select'는 망가지지 않았다.**

어떤 버그 때문에 추가한 땜질 코드가 버그 해결 후 망가질 수도 있다.

### 놀라운 구석

**가정하지 말라. 증명하라**

버그를 미리 잡을 수 있도록 단위 테스트나 다른 테스트를 수정할 필요가 있는지 고민해 보라.

버그를 수정하는 김에, 이것과 동일한 버그가 있을 법한 다른 코드가 있는지 살펴보고, 고쳐라.

버그를 고치는 데 시간이 오래 걸렸다면, 어떻게 하면 다음에는 더 쉽게 고칠 수 있을지 생각해라. 더 나은 테스트 훅을 만들어 놓거나, 로그 파일 분석기를 작성할 수도 있겠다.

### 디버깅 체크리스트

1. 보고된 문제가 내재하는 버그의 직접적 결과인가 아니면 단순히 증상일뿐인가?

2. 버그가 정말로 여러분이 사용하는 프레임워크에 있나? OS에? 아니면 내 코드?

3. 의심 가는 코드가 단위 테스트를 통과한다면 테스트는 충분히 갖춰진 것인가? 이 데이터로 테스트를 돌리면 무슨 일이 생기는가?

등등

## 텍스트 처리

**텍스트 처리 언어를 익혀라**

## 엔지니어링 일지

일지를 쓰면 좋은 점 3가지!

1. 기억보다 더 믿을 만하다. 사람들이 이러 질문을 한다고 생각해보자. ~~이름이 뭐였지? -> 수첩을 넘기면 이름과 전화번호를 알 수 있다.

2. 진행 중인 작업과 직접적인 관계가 없는 발상을 일단 쌓아 놓을 수 있는 곳이 생긴다. 그러면 위대한 발상을 잊어버릴 걱정 없이 지금 하는 일에 계속해서 집중할 수 있다.

3. 무언가를 쓰기 위해 하던 일을 멈추면 여러분의 뇌도 기어를 바꾼다. 누군가에게 이야기를 하는 것과 비슷하다. 하던 일을 돌아보기에 알맞은 기회가 생기는 것이다. 메모를 시작하자마자 메모의 주제인 여러분이 방금 전까지 하던 일이 말도 안된다는 것을 깨닫게 될 수도 있다.

... 요즘 일상에서 일지를 쓰고 있는데, 되게 공감이 가는 말들이다.

# 4장 - 실용주의 편집증

**여러분은 완벽한 소프트웨어를 만들 수 없다.**
... ㅠㅠ

이 말에 상처받았는가? 그러면 안된다. 삶의 공리로 인정하고 받아들여라.

그래서 우리는 방어적으로 코딩하라고 배운다.

잘못된 데이터를 찾아내기 위해 단정문을 사용하고, 공격자나 불량 사용자가 만들었을지도 모르는 데이터를 불신한다. 하지만 데이터베이스 칼럼에 제약을 거는 정도로 뿌듯해하는 경우가 대부분이다.

실용주의 프로그래머는 자기 자신조차 믿지않는다.
어느 누구도, 심지어는 자기 자신도 완벽한 코드를 작성할 수 없음을 알기 때문에 실용주의 프로그래머는 자신의 실수에 대비한 방어책을 마련한다.

## 계약에 의한 설계

정직한 거래를 보장하는 최선의 해법 중 하나는 '계약'이다.

계약에 의한 설계는 단순하지만 강력한 기법으로, 프로그램의 정확성을 보장하기 위해 소프트웨어 모듈의 권리와 책임을 문서화하고 합의.

함수의 전제와 선언을 다음과 같이 설명할 수 있다.

1. 선행 조건

- 루틴이 호출되기 위해 참이어야 하는 것.(루틴의 요구사항)

2. 후행 조건

- 루틴이 자기가 할 것이라고 보장하는 것.(루틴이 완료되었을 때의 상태)

3. 클래스 불변식

- 클래스는 불변식에 관여하는 데이터 멤버의 제한 없는 쓰기를 허용하지 않는 것.

루틴과 그 루틴을 호출하려는 코드 간의 계약은 다음과 같다.

**만약 호출자가 루틴의 모든 선행 조건을 충족한다면 해당 륀은 종료 시 모든 후행 조건과 불변식이 참이 되는 것을 보장한다.**

**계약으로 설계하라.**

의미론적 불변식을 사용하면 일종의 철학적 계약인 절대 어겨서는 안되는 요구 사항을 표현할 수 있다.

의미론적 불변식은 무언가가 품은 진짜 의미의 중심이 되어야 하며, 훨씬 역동적으로 변하는 비즈니스 규칙처럼 일시적인 정책에 영향을 받으면 안된다.

이는 모든 시스템 사용자와 맺는 계약이며 동작에 대한 우리의 보증이다.

## 죽은 프로그램은 거짓말을 하지 않는다.

모든 오류는 정보를 준다. 우리는 오류가 발생할 리 없다고 자신을 설득하고선 그걸 무시하기로 할 수도 있다. 오류 메시지좀 읽어라.

### 잡은 후 그냥 놓아주는 것은 물고기뿐.

**일찍 작동을 멈춰라**

### 망치지 말고 멈춰라

기본 원칙은 똑같다. 방금 있을 수 없는 일이 발생했다는 것을 코드가 발견했다면 프로그램은 더는 유효하지 않다. 이 시점 이후로 하는 일은 모두 잘못된 결과일 수 있기 때문에 되도록 빨리 종료하라.

... 프론트 입장에서는 어떤 부분에서 예시를 들 수 있을지 고민

### 단정적 프로그래밍

**단정문으로 불가능한 상황을 예방하라**

매개변수나 결과가 절대 null값이 될 수 없다는 단정문을 통해 명시적으로 표현하라.

단정문에 문자열을 이용해 설명을 추가할 수도 있다.

단정은 결코 일어나서는 안되는 일을 뜻한다. 오류 처리를 해야 하는 곳에 단정문을 작성하면 안된다.

### 단정의 부작용

문제를 발견하려고 넣은 코드가 오히려 새로운 문제를 발생시킬 수도 있다.

디버깅 행위가 디버깅 시스템의 행동을 바꿔버리는 '하이젠버그'가 발생한다.

### 단정 기능을 사용하라

프로그램을 출시하고 단정 기능을 제거하는 것은 보험이 없는 것이나 마찬가지이다. 성능 문제가 생기더라도, 정말 문제가 되는 단정문만 제거하도록 하자. 해당하는 단정을 제외하고는 그대로 둬라.

### 리소스 사용의 균형

**자신이 시작한 것은 자신이 끝내라**

리소스를 할당하는 함수나 객체가 리소스를 해제하는 책임 역시 져야 한다는 뜻이다.

잘 모르겠을 때는 스코프를 줄이는게 최고다.

**지역적으로 행동하라**

### 중첩 할당

1. 리소스를 할당한 순서의 역순으로 해체하라. 이렇게 해야 한 리소스가 다른 리소스를 참조하는 경우에도 참조를 망가트리지 않는다.

2. 코드의 여러 곳에서 동일한 구성의 리소스들을 할당하는 경우에는 언제나 같은 순서로 할당해야 교착 가능성을 줄일 수 있다.

### 객체와 예외

할당과 해재 사이의 균형은 객체 지향 클래스의 생성자와 소멸자를 연상시킨다.

생성자는 이 자원 타입의 특정 객체를 만들어주고, 소멸자는 스코프에서 그 객체를 제거해준다.

이 접근법은 예외 때문에 리소스 해제가 제대로 되지 않을 수 있는 언어로 작업할 때에 특히 쓸모 있다.

### 균형 잡기와 예외

예외 발생 이전에 할당된 모든 것이 깨끗이 청소된다고 어떻게 보장할 수 있을까? 2가지 방법이 있다.

1. 변수 스코프를 사용한다.
2. try - catch 블록에서 finally 절을 사용한다.

### 리소스 사용의 균형을 잡을 수 없는 경우

자료 구조에서 최상위 구조의 메모리 할당을 해제할 경우 어떻게 처리해야 할까? 3가지 방법이 있다.

1. 최상위 구조가 자기 안에 들어 있는 하위 구조들을 해제할 책임을 진다.

2. 최상위 구조가 그냥 할당 해제된다.

3. 최상위 구조가 하나라도 하위 구조를 가지고 있으면 자신의 할당 해제를 거부한다.

선택은 각 자료 구조의 상황에 따라 달라진다. 언제나 어떤 것을 선택할지 확실하게 정하고 그에 따라 일관성 있게 구현하는 것이 중요하다.

...자료구조 수업을 들었는데도 어렵다.

### 균형을 점검하기

리소스의 종류 별로 Wrapper를 만들고 그 래퍼들이 모든 할당과 해제 기록을 보관한다. 프로그램 논리에 따르자면 자원들이 반드시 특정한 상태에 있어야 한다고 지정할 수 있는 지점들이 코드 속에 있을 것이다. 래퍼를 사용해서 상태가 올바른지 점검해라.

더 낮은 수준에서는 프로그램이 실행될 때 메모리가 새는지 검사하는 도구를 사용할 수도 있다.

### 헤드라이트를 앞서가지 말라

**작은 단계들을 밟아라. 언제나**

불확실한 미래에 대비한 설계를 하느라 진을 빼는 대신 언제나 교체 가능한 코드를 작성하여 대비하라. 코드를 교체할 수 있도록 하면 응집도나 결합도, DRY(중복 제거) 에도 도움이 되고, 전반적으로 더 나은 설계가 탄생한다.

### 블랙 스완

**예언하지 말라**
대부분의 경우 내일은 오늘과 거의 같다. 하지만 확신하지는 마라.
