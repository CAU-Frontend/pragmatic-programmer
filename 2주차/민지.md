# 3장. 기본도구

도구가 더 훌륭하고 사용에 익숙해질수록 생산성은 더 높아질 것이다.

IDE가 갖는 한계를 넘어설 수 있어야 한다. 유일한 방법은 기본 도구들을 언제나 곧바로 사용할 수 있도록 예리하게 유지하는 것.

## 일반 텍스트의 힘

> **TIP25. 지식을 일반 텍스트로 저장하라**
> 

일반 텍스트? 이진 포맷처럼 기계를 통해 해석해야 하는 데이터가 아니라 사람이 바로 이해할 수 있는 데이터

HTML, JSON, HTTP 등도 대부분 일반 텍스트

일반 텍스트는 그 자체만으로 의미가 드러나므로 오래 살아 남을 수 있다. 형식만 알면 다른 형태의 데이터로도 쉽게 파싱해 유지할 수 있음.

시스템이 고장 났을 때 매우 제한적인 환경에서 복구 작업을 해야하는 경우.. 일반 텍스트의 단순함이 유용. 다양한 시스템이 섞인 환경에서도 일반 텍스트가 공통 표준이 되어줄 것.

## 셸 가지고 놀기

> **TIP26. 명령어 셸의 힘을 사용하라.**
> 

모든 작업을 GUI로만 하면 환경의 능력을 전부 이용할 수 없다.

GUI의 장점은 What you see is What you get, 반대로 단점은 What you see is all you get… ← 인정

⇒ 셸 잘 쓰고 싶은데… 언제 공부하지

## 파워 에디팅

> **TIP27. 에디터를 유창하게 쓸 수 있게 하라.**
> 

어떤 것이 유창한 것인가

- 텍스트를 편집 할 때 문자, 단어, 줄, 문단 단위로 커서를 이동하거나 내용을 선택
- 코드를 편집할 때 반대쪽 괄호로 이동하거나, 함수, 모듈 등 다양한 문법 단위로 커서를 이동
- 변경한 코드의 들여쓰기를 자동으로 맞추기
- 여러 줄의 코드를 주석/주석해제
- 실행 취소를 여러번, 재실행
- 에디터 창을 여러 구역으로 쪼개기/이동

등등…~~이제 VScode는 어느 정도 유창하지 않을까 (해야 하지 않을까)~~

- 키보드 단축키만으로도 에디터 사용이 가능하게끔 도전해보기
- 플러그인 만들어보기

## 버전 관리

> **TIP28. 언제나 버전 관리 시스템을 사용하라. VSC (Version Control System)**
> 

실수를 되돌리는 것 외에도 변경사항 추적, 감사, 성능관리, 품질관리에 도움.

특정 릴리스로 돌아갈수도 있음.

## 디버깅

> **TIP29. 비난 대신 문제를 해결하라.**
> 

디버깅은 단지 문제 풀이일 뿐이라는 사실을 받아들이고 그런 마음으로 공략하라. 비난하기보다는 문제를 고치는 데에 집중해야한다…(🤖)

> **TIP30. 당황하지 말라. (디버깅 제1 법칙)**
> 

압박이 있는 상황에서 당황하기 쉽다. 한발짝 뒤로 물러나서 버그라고 생각하는 증상의 원인이 무엇일지 진짜로 생각해보는 것이 중요하다.

디버깅할 때 근시안의 함정에 주의하라. 표면에 보이는 증상만 고치려는 욕구를 이겨내라. → 반성.. 항상 문제의 근본 원인을 찾으려고 노력하라

### 실마리 찾기

어떤 문제건 해결을 하려면 관련 자료를 모두 모아야한다.

- 처음에 받은 자료 이상을 얻기 위해서 버그를 보고한 사용자를 인터뷰할 필요도 있다.
- 인공적인 테스트는 애플리케이션을 충분히 테스트하지 못한다. 경계 조건과 실제 최종 사용자의 사용 패턴 모두를 철저히 테스트해야한다.

버그를 재현하기 위해서 여러 단계를 거쳐야 할 수도 있음 → 오히려 수정이 어려워진다.

> **TIP31. 코드를 고치기 전 실패하는 테스트부터.**
> 

버그가 발생하는 상황을 다른 것들로부터 분리하다보면 통찰을 얻을 수 있기도 함. 테스트 작성..

결국 ETC하게, 테스트를 위한 의존성을 최소화할 수 있도록 코드를 개선해야한다.

> **TIP32. 그놈의 오류 메시지 좀 읽어라**
> 

무지성 코드 돌진말고 메시지를 읽고 문제가 무엇인지 살피자.

### 이진 분할(이진 탐색)

특정 데이터 셋이 들어오면 죽어버리는 경우 입력값 추적이 어려움 → 이진 분할 같은 알고리즘을 통해 해결하고자 하기. O(logN)

### 로깅과 트레이싱

트레이싱 구문은 화면 혹은 파일에 출력하는 작은 진단용 메시지. 트레이싱은 여러 프로세스가 동시에 작동하는 경우, 실시간 시스템, 이벤트 기발 애플리케이션 등 시간 자체가 중요한 요소가 되는 시스템에서 좋음.

### 고무오리

그냥 누군가에게 문제를 설명하는 방법. 차근차근 설명해 나가는 단순한 행위로도 확인 가능.

> **TIP33. “select”는 망가지지 않았다.**
> 

OS나 컴파일러 혹은 외부 제품에 버그가 있을 수도 있다. 하지만 처음부터 그런 생각을 하지는 말라.

→ 실제로 쉐어드 워커 사용할 때 워커 스크립트가 임포트가 안되는 문제를 ‘트리쉐이킹’의 문제로 짐작하고 넘어갔던… 해당 부분을 발표하면서 지적받았고, 문서를 다시 읽어보니 호출 방식의 문제였다. 트랜스파일링 과정을 제대로 이해하지 못했음.

각주구검

> **TIP34. 가정하지 말라. 증명하라.**
> 

디버깅 체크 리스트

- 보고된 문제가 내재하는 버그의 직접적 결과인가 아니면 단순히 증상일 뿐인가?
- 버그가 정말로 여러분이 사용하는 프레임워크에 있나? OS에? 아니면 여러분 코드에 있나?
- 이 문제를 동료에게 상세히 설명한다면 어떻게 말하겠는가?
- 의심 가는 코드가 단위 테스트를 통과한다면 테스트는 충분히 갖춰진 것인가? 이 데이터로 테스트를 돌리면 무슨 일이 생기는가?
- 이 버그를 야기한 조건이 시스템의 다른 곳에도 존재하는가? 다른 버그가 유충 단계에서 성충이 될 날만 기다리고 있는 것은 아닌가?

## 텍스트 처리

> **TIP35. 텍스트 처리 언어를 익혀라.**
> 

여러분은 매일 많은 시간을 텍스트와 씨름하며 보낸다. 왜 그중 일부를 컴퓨터에게 맡기지 않는가?

---

# 4장. 실용주의 편집증

> **TIP36. 여러분은 완벽한 소프트웨어를 만들 수 없다.**
> 

실용주의 프로그래머는 자기 자신 역시 믿지 않는다. 

## 계약에 의한 설계 (Design By Contract, DBC)

정직한 거래를 보장하는 최선의 해법 중 하나는 ‘계약’ → 소프트웨어 모듈 간 소통에 적용

> **TIP37. 계약으로 설계하라.**
> 

프로그램의 정확성을 보장하기 위해 소프트웨어 모듈의 권리와 책임을 문서화하고 합의하는 데에 초점

- 전제와 선언
    - 선행 조건: 함수, 루틴이 호출되기 위해 참이어야 하는 것
    - 후행 조건: 루틴이 자기가 할 것이라고 보장하는 것
    - 클래스 불변식: 호출자의 입장에서 볼 때는 이 조건이 언제나 참인 것을 클래스가 보장함
    
    → 만약 호출자가 루틴의 모든 선행 조건을 충족한다면 해당 루틴은 종료 시 모든 후행 조건과 불변식이 참이 되는 것을 보장한다.
    
    ⇒ 계약 당사자 중에 어느 한쪽이라도 계약 내용을 지키지 못하면 해결 방안이 실행된다. 예외 처리라던가 프로그램 종료 등… 아무튼 계약 되지 않은 것은 버그다.
    

DBC는 모든 입력값에 대해 성공과 실패를 정의한다(즉 선행 조건에서 입력값을 거르거나 하지 않음). 반면 테스트는 하나가 한 가지 경우만 다룬다.

TDD는 멋진 개법이다. 하지만 다른 많은 기법과 마찬가지로 ‘정상 경로’에만 집중하도록 유도하기도 한다. 그러나 바깥세상은 나쁜 데이터와 나쁜 사람들, 나쁜 버전, 나쁜 명세로 가득 차 있다.

의미론적 불변식은 무언가가 품은 진짜 의미의 중심이 되어야 하며, 훨씬 역동적으로 변하는 비즈니스 규칙처럼 일시적인 정책에 영향을 받으면 안된다. 

## 죽은 프로그램은 거짓말 하지 않는다

### 잡은 후 그냥 놓아주는 것은 물고기뿐

어떤 함수에서 발생할 에러를 고려해 catch… 로그 찍고 다시 throw?

→ 어플리케이션 코드가 오류 처리 코드 사이에 묻힘. 코드의 결합도가 높아짐

> **TIP38. 일찍 작동을 멈춰라**
> 

상위 호출 스택에 맞기자.. 에러바운더리 서스펜스처럼

## 단정적 프로그래밍

> **TIP39. 단정문으로 불가능한 상황을 예방하라.**
> 

"하지만 그런 일은 절대 일어나지 않을 거야." → 실제로는 일어날 수도 있다. → 그렇다면 일어나지 않는다는 것을 코드로 강제해야 한다.

```jsx
function assert(condition, message = "Assertion failed") {
  if (!condition) {
    throw new Error(message);
  }
}
```

```jsx
function divide(a, b) {
  assert(typeof a === "number" && typeof b === "number", "Inputs must be numbers");
  assert(b !== 0, "Cannot divide by zero");

  return a / b;
}

console.log(divide(10, 2)); // ✅ 정상 동작
console.log(divide(10, "2")); // ❌ 에러 발생: Inputs must be numbers
console.log(divide(10, 0)); // ❌ 에러 발생: Cannot divide by zero
```

## 리소스 사용의 균형

> **TIP40. 자신이 시작한 것은 자신이 끝내라.**
> 

리소스를 할당하는 함수나 객체가 리소스를 해제하는 책임 역시 져야 한다는 뜻일 뿐이다.

> **TIP41. 지역적으로 행동하라.**
> 

잘 모르겠을 땐 언제나 스코프를 줄이는 편이 낫다.

리소스를 할당한 순서의 역순으로 해제하라. 이렇게 해야 . 한 리소스가 다른 리소스를 참조하는 경우에도 참조를 망가트리지 않는다.

코드의 여러 곳에서 동일한 구성의 리소스들을 할당하는 경우에는 언제나 같은 순서로 할당해야 교착 가능성을 줄일 수 있다. 데드락.

### 리소스 사용의 균형을 잡을 수 없는 경우

동적인 자료구조를 사용하는 경우.. 최상위 구조의 메모리 할당을 해제할 경우 어떻게 처리해야할까?

- 최상위 구조가 자기 안에 들어 있는 하위 구조들을 해제할 책임을 진다.
- 최상위 구조가 그냥 할당 해제된다.
- 최상위 구조가 하나라도 하위 구조를 가지고 있으면 자신의 할당 해제를 거부한다.

js는 가비지컬렉터가 있으니까.. 순환 참조만 조심하기?

## 헤드라이트를 앞서가지 말라

헤드라이트는 ‘투사 거리’라고 부르는 범위까지만 밝힐 수 있다. 이 범위 바깥은 빛이 너무 분산되어 효과가 떨어진다. 이로 인해 차가 헤드라이트를 앞서나가 사고가 발생한다.

> **TIP42. 작은 단계를 밟아라. 언제나.**
> 

언제나 신중하게 작은 단계들을 밟아라. 더 진행하기 전에 피드백을 확인하고 조정하라. 피드백의 빈도를 여러분의 제한 속도라고 생각하라. 애자일!

> **TIP43. 예언하지 말라.**
> 

대부분의 경우 내일은 오늘과 거의 같을 것이다. 하지만 확신하지는 말라.
