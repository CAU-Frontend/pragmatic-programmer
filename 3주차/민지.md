# 5장. 구부러지거나 부러지거나

## 결합도 줄이기

소프트웨어의 구조는 유연해야 한다. 그리고 유연하려면 각각의 부품이 다른 부품에 가능한 한 조금만 연결되어야 한다.

결합이 추이적 - 결국 A가 B,C와 B, C가 …Y,Z와, 결국 A는 모두와 결합되어 있는 것

> **TIP44. 결합도가 낮은 코드가 바꾸기 쉽다.**
> 

### 열차사고

기차의 모든 객차가 서로 연결되어 있듯이 메서드나 속성들이 모두 연결되어 있는 코드 = 열차 사고

> **TIP45. 묻지 말고 말하라 Tell, Don’t Ask, TDA.**
> 

다른 객체의 내부 상태에 따라 판단을 내리고 그 객체를 갱신해서는 안된다는 것.

→ 객체의 내부 상태를 묻는 것으로 인하여 캡슐화의 장점은 완전히 사라지고, 지식이 여기저기 퍼져버림.

⇒ 적합한 책임을 갖는 객체에 관련 처리를 위임하자

- 데메테르

> **TIP46. 메서드 호출을 엮지말라.**
> 

무언가에 접근할 때 `.` 를 딱 하나만 쓰려고 노력해보라. 

- 연쇄와 파이프라인

파이프라인은 메서드 호출로 이루어진 열차 사고와는 다르다. 숨겨진 구현 세부 사항에 의존하지 않기 때문이다.

파이프라인의 함수에서 반환하는 데이터는 반드시 다음 함수가 처리할 수 있는 형식이어야 한다.

### 글로벌화의 해악

> **TIP47. 전역 데이터를 피하라.**
> 

전역 데이터는 어플리케이션의 모든 메서드에 갑자기 매개 변수가 추가된 것과 같은 효과를 낸다.

단위테스트를 준비하기에도 어려움.

- 싱글턴도 전역 데이터다.
- 외부 리소스도 전역 데이터다. DB, FS, API 등… → 해법은 리소스들을 작성하는 코드로 모두 감싸는 것

> **TIP48. 전역적이어야 할 만큼 중요하다면 API로 감싸라.**
> 

⇒ 결국엔 ETC, 직접적으로 아는 것만 다루는 부끄럼쟁이 코드를 계속 유지하라.

## 실세계를 갖고 저글링하기

반응적인 애플리케이션을 작성하는 법

### 이벤트

이벤트는 무언가 정보가 있다는 것. 어떻게 이벤트에 잘 반응하는 애플리케이션을 만들 수 있을까?

### 유한 상태 기계 Finite State Machine, FSM

오토마타….?

1. 상태마다 그 상태일 때 의미가 있는 이벤트들을 나열하고, 이벤트별로 시스템의 다음 ‘현재 상태’를 정의한다.
2. 특정한 상태 이행이 일어날 때 수행하는 액션을 추가

### 감시자 패턴 Observer pattern & 게시-구독 Pub-Sub

- react query, redux, event emitter, web socket.. 곳곳에서 찾을 수 있다.

### 반응형 프로그래밍과 스트림 그리고 이벤트

값이 바뀌면 그 값을 사용하는 다른 값이 ‘반응하는(react)’ 것

스트림은 이벤트를 일반적인 자료구조처럼 다룰 수 있게 해줌. 리스트와 같음. 이벤트가 추가되면 이벤트 스트림의 길이가 길어짐. 

## 변환 프로그래밍

> **TIP49. 프로그래밍은 코드에 관한 것이지만, 프로그램은 데이터에 관한 것이다.**
> 

연속된 변환으로 데이터를 가공하고 결과를 출력한다.

- 변환 찾기 - 요구 사항에서 입력과 출력이 무엇인지 알고, 입력을 출력으로 바꿔 가는 단계들을 찾기. 일종의 하향식, 이후 더 작은 변환들로 나누기

> **TIP50. 상태를 쌓아 놓지 말고 전달하라.**
> 

OOP는 데이터를 숨기고 객체 안에 캡슐화를 함. 서로 이야기 하며 서로의 상태를 변경 → 결합 증가..

변환 모델에서는 데이터가 특정 함수들과 묶이지 않고 자유로워짐 결합도 감소

## 상속세

상속도 일종의 결합이다. 코드를 공유하기 위해 상속을 사용하면 모든 조상과 얽힘

타입을 정의하기 위해 상속을 쓰면.. 여러 타입에 속해있을 때 다중상속의 문제 발생.

> **TIP51. 상속세를 내지 말라.**
> 

더 나은 대안

- 인터페이스와 프로토콜
    - 구현해야 할 특정 동작을 지정
        
        > **TIP52. 다형성은 인터페이스로 표현하는 것이 좋다.**
        > 
- 위임:
    - 상속으로 불필요한 메서드까지 안고있지말고 필요한 메서드만 위임받기
        
        > **TIP53. 서비스에 위임하라. Has-A가 Is-A보다 낫다.**
        > 
- 믹스인, 트레이트, 카테고리, 프로토콜 확장 등
    - 클래스나 객체를 필요할때마다 직접 코드로 확장하는 것이 아니라. 기존 것과 새로운 것의 기능 집합을 합치기
    - js에서는 `Object.assign`
    
    ```jsx
    const canSing = {
      sing() {
        console.log(`${this.name}가 노래합니다! 🎤`);
      }
    };
    
    function Person(name) {
      this.name = name;
    }
    
    // 프로토타입에 믹스인 추가
    Object.assign(Person.prototype, canSing);
    
    const singer = new Person("가수");
    singer.sing(); // 가수가 노래합니다! 🎤
    
    ```
    

상속이 답인 경우는 드물다. 바나나를 가져오려고 정글 전체를 끌어들이지 않도록 하자.

## 설정

애플리케이션이 출시된 이후 바뀔 수도 있는 값에 코드가 의존하고 있다면 그 값을 애플리케이션 외부에서 관리하라.

> **TIP55. 외부 설정으로 애플리케이션을 조정할 수 있게 하라.**
> 
- 정적 설정
    - yaml, json
- 서비스형 설정
    - .env이런거
- 도도 코드를 작성하지 말라.
    - 외부 설정을 사용하지 않는다면 코드는 적응성이나 유연성을 어느정도 포기해야만 한다.

---

# 6장. 동시성

- 동시성: 둘 이상의 코드 조각이 실행될 때 동시에 실행 중인 것처럼 행동하는 것
    - 동시성을 얻으려면 실행 중에 코드의 다른 부분으로 실행을 전환할 수 있는 환경에서 코드를 구동해야한다.
    - 리액트 파이버가 그 환경을 만든 예시일듯..
    - 인터럽트
- 병렬성: 실제로 동시에 실행되는 것.

## 시간적 결합 깨트리기

함수형 프로그래밍과 비슷한 부분.. 동시성 개선

> **TIP56. 작업 흐름 분석으로 동시성을 개선하라.**
> 

동시에 일어나는 것이 무엇인지 타임라인을 그려보기. 활동 다이어그램

동시에 해도 상관없는 것들은 동시에!

## 공유 상태는 틀린 상태

> **TIP57. 공유 상태는 틀린 상태다.**
> 

### 비원자적 갱신

하나의 상태를 여럿이 공유할때… 두 작업을 동시에 해버리면 두 프로세스가 같은 메모리 영역에 쓰게 될 수 있다. → 비원자적 갱신

그럼 어떻게 원자적으로?

- 세마포어 및 다른 상호 배제 방법
    - 세마포어는 단순히 한 번에 한 사람만이 가질 수 있는 무언가.
    - 주문을 받기 전에 특정 인형을 가지고 있어야함. lock, unlock.
    - but 누군가 이 룰을 까먹는 다면 문제 발생
- 리소스를 트랜잭션으로 관리하라.
    - 작업 시작 전 lock, 끝나거나 예외 발생 시 unlock
    
    → 세마포어는 공중 화장실 키, 뮤텍스는 개인 화장실 키
    

> **TIP58. 불규칙한 실패는 동시성 문제인 경우가 많다.**
> 

## 액터와 프로세스

액터와 프로세스를 사용하면 흥미로운 방식으로 동시성을 구현할 수 있다.

- 액터
    - 자신만의 비공개 지역 상태를 가진 독립적인 가상처리 장치다.
    - 각 액터는 우편함을 하나씩 보유하고 있다.
    - 액터가 잠자고 있을 때 우편함에 메시지가 도착하면 액터가 깨어나서 메시지를 처리한다.
    - 처리가 끝나면 우편함의 다른 메시지를 처리한다.
    - 만약 우편함이 비어있으면 다시 잠든다.
    - 메시지를 처리할 때 액터는 다른 액터를 생성하거나, 알고있는 액터에게 메시지를 보내거나, 다음 메시지를 처리할 때의 상태가 될 새로운 상태를 생성할 수 있다.
        
        ⇒
        
- 프로세스
    - 본래 더 일반적인 가상 처리기
    - 운영체제가 동시성을 지원하기 위하여 구현한다.

> **TIP59. 공유 상태 없는 동시성을 위하여 액터를 사용하라.**
> 

액터는 아무것도 공유하지 않으면서 비동기적으로 동시에 실행됨. 

## 칠판

형사들이 사건 조사할때 칠판을 사용하는 모습

- 형사들은 다른 형사의 존재를 알 필요가 없다.
- 형사들은 여러 유형이고 사건을 해결하고 싶은 마음만 공통점이다.
- 수사 과정에서 여러 형사들이 다양한 시간에 접근한다.
- 칠판에는 제한 없이 어떤 것이든 올릴 수 있다.

일종의 ‘자유방임주의’적 동시성임. 

금융 기능처럼 법적 요구사항이 복잡한 경우. 법적요구 사항을 캡슐화하는 규칙 엔진과 함께 사용. 

- 어떤 사실이 칠판에 올라가면 적절한 규칙이 발동되도록 하면 된다.
- 결과에 대한 피드백도 마찬가지이다.어떤 규칙에서 나온 것이든 그 결과를 다시 칠판에 올려서 다른 규칙들이 발동 되록하면 된다.

> **TIP60. 칠판으로 작업 흐름을 조율하라.**
> 

분석이 어렵… 이런 경우 로그를 남겨서 살펴보자
