# 7장. 코딩하는 동안

코딩은 기계적인 작업이 아니다. 사려 깊은 생각과 판단으로 결정을 내려야 한다.

## Topic 37. 파충류의 뇌에 귀 기울이기

본능이란 우리 뇌의 무의식 속에 채워져 있는 패턴에 대한 단순한 반응이다. 일부는 선천적이고 나머지는 반복을 통해 습득한다. 본능은 ‘말로 표현할 수 없다는’ 공통점이 있다.

우선 본능이 반응하고 있음을 인지하고, 왜 그런 느낌이 드는지를 알아내야 한다.

처음 프로젝트를 시작하는 일이 두려움 why?

1. 본능에 있는 모종의 의심. 직감.
2. 그저 실수할까 봐 두려움

코드를 짜는게 자꾸 더뎌짐 → 그냥 견디기? no. 코드가 무언가 말하려는 것이다. 설계나 구조가 잘못되었거나 엉뚱한 문제를 풀고 있거나…

### 파충류와 이야기하는 법

> **TIP61. 여러분 내면의 파충류에게 귀 기울여라.**
> 

일단 하고 있는 일을 멈춰라. 쉬면서 생각이 저절로 여러분의 뇌 층층이 스며들도록 놔둬라.

위 방법이 잘 안되면 문제를 표면으로 끄집어내 보라. 작성하는 코드에 대한 그림을 그리거나 동료에게 설명해보기.

이것저것 시도해보았는데 안되면? 행동해야 할 시간. 프로토타이핑을 통해 문제가 없다고 뇌에게 알려주기.

### 놀이 시간이다!

프로토타이핑으로 만들어라.

1. 포스트잇에 ‘프로토타이핑 중’이라고 써서 모니터 옆에 붙여라
2. 프로토타이핑은 원래 실패한다고 자신에게 상기시켜라. 실패하지 않더라도 프로토타입은 버리는 것이라는 점도 함께 상기. 프로토타이핑으로 손해 볼 일은 없다.
3. 텅 빈 에디터 화면에 여러분이 배우고 싶은 것 혹은 하고 싶은 것을 한 문장의 주석으로 표현해 보라
4. 코딩을 시작하라

실제로 워커스레드+소켓 사용할 때 프로토타이핑으로 간단한 채팅을 구현하고 나니까 어떻게 기존 프로젝트에 접근해야 할 지 막막했던 감정이 사라지는…

직감에 귀를 기울이자

## Topic 38. 우연에 맡기는 프로그래밍

우연이 아닌 의도적으로 프로그래밍 해야 한다.

### 우연에 맡기는 프로그래밍 하기

어 잘 돌아가네? 타닥타닥 → 갑자기 안 됨 → 왜 안되는지 찾아보아도 안 돌아감

why? 애초에 코드가 왜 잘 돌아가는지도 몰랐기 때문.

우리는 그냥 지뢰를 잠시 피했을 뿐

그냥 우리가 원하는 화면이 나왔다고 넘어가면 불필요한 호출이 있거나, 실제로 라이브러리가 의도한 동작이 아닌 경우가 왕왕 있음.

→ 문서화된 동작에만 의존하라. 그럴 수 없다면 추측을 문서로 상세히 남겨라

비슷하다고 괜찮을리 x. 눈에 보이는 오차만 바로 수정? → 오차가 쌓이고 쌓여서 스노우볼이 됨.

특정한 상황에서만 돌아가도록 만든 코드, 확실한 것이 아닌데도 의존하게 됨…

잘 되는 듯한 답을 찾는 것과 올바른 답을 찾는 것은 다르다.

> **TIP62. 우연에 맡기는 프로그래밍을 하지 말라.**
> 

암묵적인 가정. 확고한 사실에 근거하지 않은 가정은 재앙이다. 테스트가 특히 가짜 원인과 우연한 결과로 가득 찬 영역이다.

### 의도적으로 프로그래밍하기

우연에 맡기지 않고 의도적으로 하자

- 언제나 내가 지금 무엇을 하고 있는지 알아야 한다.
- 더 경험이 적은 프로그래머에게 코드를 상세히 설명할 수 있어야 한다.
- 자신도 잘 모르는 코드를 만들지 말라. 우연의 함정에 빠질 가능성이 높다. 왜 동작하는지 모르면 왜 실패하는지도 알 리가 없다.
    - 만약 마감기한 내에 잘 사용해보지 못한 라이브러리를 써야 한다면? 어떻게 해야할까…
- 계획을 세우고 그것을 바탕으로 진행하라
- 신뢰할 수 있는 것에만 기대라. 가정에 의존하지 말라. 무언가 신뢰할 수 있을지 판단하기 어렵다면 일단 최악의 상황을 가정하라
- 가정을 기록으로 남겨라.
- 코드뿐 아니라 우리가 세운 가정도 테스트해 보아야 한다. 단정문을 작성하라
- 노력을 기울일 대상의 우선순위를 정하라.
- 과거의 노예가 되지 말라. 기존 코드가 앞으로 짤 코드를 지배하도록 놓아두지 말라. 언제나 리팩터링할 자세가 되어 있어야 한다.

## Topic 39. 알고리즘의 속도

알고리즘이 사용하는 자원, 곧 시간, 프로세서, 메모리 등을 추정 → 어떻게 추정할 수 있을까?

### 대문자 O 표기법

우리가 측정하는 값-시간, 메모리- 등의 상한을 기술하는 표기법

n이 커질수록 가장 큰 차수에 비하면 다른 차수는 무시해도 될 정도이기 때문에 관습적으로 최상위 차수를 제외한 다른 모든 차수는 제거

> **TIP63. 사용하는 알고리즘의 차수를 추정하라.**
> 

입력 데이터 집합이 작을 때는 수행 시간이 선형적으로 늘어나다가도, 수백만 개의 레코드를 입력하면 스레싱이 발생해 수행시간이 폭증하기도 함.

(스레싱: 과도한 메모리 사용으로 인하여 지속해서 페이지 폴트가 발생하는 상황을 의미)

> **TIP64. 여러분의 추정을 테스트하라.**
> 

코드 프로파일러를 사용해 알고리즘이 돌아갈 때 각 단계의 실행 횟수를 세고 입력값 크기별 실행 횟수를 그래프로 그려보기.

리액트의 useMemo도 DP를 사용한다. 아는 사람과 모르는 사람의 컴퓨팅 사고력 차이는 확실함

https://velog.io/@teo/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%EA%B0%9C%EB%B0%9C%EC%9E%90%EC%97%90%EA%B2%8C-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EA%B3%B5%EB%B6%80%EA%B0%80-%EB%AF%B8%EC%B9%98%EB%8A%94-%EC%98%81%ED%96%A5#%EA%B7%B8%EB%A0%87%EB%8B%A4%EB%A9%B4-%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%EB%8A%94-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%9D%84-%EB%AA%B0%EB%9D%BC%EB%8F%84-%EB%90%98%EC%A7%80-%EC%95%8A%EB%82%98%EC%9A%94

동시편집과 같은 복잡한 기능을 구현하게 될때도…

but 입력데이터의 규모가 작으면 알고리즘을 돌리는 시간이 더 듦. 성급한 최적화를 조심하라.

## Topic 40. 리팩터링

소프트웨어 개발은 건축보다 정원 가꾸기에 더 가깝다. 딱딱하기보다는 유기적인 활동이다.

리팩터링이란 밖으로 드러나는 동작은 그대로 유지한 채 내부 구조를 변경함으로써 이미 존재하는 코드를 재구성하는 체계적인 기법이다.

1. 이 활동은 체계적이며 아무렇게나 하는 것이 아니다. → 정확한 목적을 가지고 접근, ETC로 구현하는 이유
2. 밖으로 드러나는 동작은 바뀌지 않는다. 기능을 추가하는 작업이 아니다. → 자동화된 단위 테스트가 필요

### 리팩터링은 언제 하는가?

- 중복 - DRY 원칙 위반을 발견
- 직교적이지 않은 설계: 더 직교적으로 바꿀 수 있는 무언가 발견
- 더 이상 유효하지 않은 지식: 코드는 지금 상황에 뒤떨어지지 않아야 한다
- 성능: 성능을 개선하려면 시스템의 한 영역에서 다른 영역으로 기능을 옮겨야 함
- 테스트 통과: 코드를 수정하고 테스트가 통과했을 때가 다시 뛰어들어 깔끔하게 정리할 타이밍

다시 코드를 여는 것은 고통스러운 작업일 수 있다. 특히 일정 압박으로 리팩터링을 하지 않기도 한다.

리팩터링이 필요한 코드는 일종의 종양이다. 작을 때 수정하자

> **TIP65. 일찍 리팩터링하고, 자주 리팩터링하라.**
> 

리팩터링만 하는 일주일이 아니라 코딩하는 동안에 함께 진행하는 편이 더 쉽다.

### 리팩터링은 어떻게 하는가?

1. 리팩터링과 기능 추가를 동시에 하지 말라.
2. 리팩터링을 시작하기 전 든든한 테스트가 있는지 먼저 확인하라.
3. 단계를 작게 나누어서 신중하게 작업하라. 메서드 하나 쪼개기, 변수명 수정하기 등 작은 단위로 작업해야 한다.

깨진 창문을 그대로 놓아두지 말라.

## Topic 41. 테스트로 코딩하기

> **TIP66. 테스트는 버그를 찾기 위한 것이 아니다.**
> 

### 테스트가 코딩을 주도한다

> **TIP67. 테스트가 코드의 첫 번째 사용이다.**
> 

우리 메서드의 테스트 작성에 대해 생각함으로써 코드의 작성자가 아니라 사용자인 것 처럼 메서드를 외부의 시선으로 보게되었다.

무언가를 테스트하기 좋게 만들면 결합도도 낮아진다.

- TDD의 기본 주기
    - 추가하고 싶은 작은 기능 하나를 결정
    - 그 기능이 구현되었을 때 통과하게 될 테스트를 하나 작성
    - 테스트를 실행, 방금 추가한 테스트 딱 하나만 실패해야 함.
    - 실패하는 테스트를 통과시킬 수 있는 최소한의 코드만 작성. 모든 테스트가 통과하는지 확인
    - 코드를 리팩터링. 개선 후에도 테스트가 계속 통과하는지 확인

→ but TDD의 노예가 되지 않도록 해야 함 (과도한 시간투자, 많은 중복 테스트, 상향식 설계) ⇒ 큰 그림을 살피는 것을 잊지 말라.

### TDD: 목표가 어디인지 알아야 한다

하향식 설계는 전체 요구 사항을 시작할 때 다 알고 있다고 가정하지만 사실은 알 수 없다.

상향식 설계는 추상화 계층을 쌓다 보면 결국에는 하나의 최상위 해결 계층에 도착할 것이라고 가정하지만, 목표가 어디인지 모르는데 어떻게 각 계층의 기능을 결정할 수 있단 말인가?

> **TIP68. 상향식이나 하향식이 아니라 끝에서 끝까지(end to end) 만들어라.**
> 

### 단위 테스트

단위 테스트는 일종의 인위적인 환경을 구축한 다음, 테스트할 모듈의 루틴들을 호출한다. 동일한 테스트를 코드 수정 후 다시 돌려보는 것은 회귀 테스트라고 한다.

### 계약을 지키는지 테스트하기

테스트는 우리에게 두 가지를 알려준다.

1. 코드가 계약을 지키는지
2. 코드로 표현된 계약의 의미가 우리가 생각하는 것과 일치하는지

여러개의 다른 모듈에 의존하는 경우에는? 그 모듈의 하위 컴포넌트들을 모두 검증한 후에야 해당 모듈 테스트 가능

번잡할 수 있지만 이후에 벌어질지 모를 재앙을 피하려고 노력하는 것

> **TIP69. 테스트할 수 있도록 설계하라.**
> 

### 테스트 접점만들기

아무리 테스트를 잘 갖추었어도 모든 버그를 발견할 수는 없다. 로깅을 잘하거나 에러 리포트 등을 잘 활용하자.

### 테스트 문화

최악의 선택은 ‘나중에 테스트’ = ‘사실 테스트하지 않음’

> **TIP70. 여러분의 소프트웨어를 테스트하라. 그러지 않으면 사용자가 테스트하게 된다.**
> 

글쓴이의 고백 파트 → 30년 넘게 자동화 테스트를 계속 써왔고, 테스트 쓰기를 그만두며 어떤 일이 발생하는지 알아보고자 함. but 변화는 크지 않았음. why? 테스트의 이득은 대부분 테스트에 대해 대하여, 테스트가 코드에 주는 영향에 대하여 고민하는 과정에서 생기는 듯 함

이전에 시니어 개발자분들이 TDD 선호하지 않는 느낌이 있었는데, 아마 이미 ETC한 코드를 짜는 것에 익숙해져서? 더이상 자잘한 테스트까지 할 필요를 느끼지 못해서일까? 아무튼 테스트를 안 한다는건 아니고 때가 되면 도움이 되는 선에서 테스트를 작성하면 좋겠다.

## Topic42. 속성 기반 테스트

우리가 코드를 쓰고 테스트를 작성하면 잘못된 가정이 둘 다에 들어갈 수도 있다. 코드에 들어갈 수 있는 속성을 찾아서 테스트 자동화에 사용하기.

> **TIP71. 속성 기반 테스트로 가정을 검증하라.**
> 

## Topic43. 바깥에서는 안전에 주의하라

### 기본 보안 원칙

1. 공격 표면을 최소화하라.
2. 최소 권한 원칙
3. 안전한 기본값
4. 민감 정보를 암호화하라.
5. 보안 업데이트를 적용하라.

> **TIP72. 단순함을 유지하고 공격 표면을 최소화하라.**
> 

> **TIP73. 보안 패치를 신속히 적용하라.**
> 

## Topic44. 이름 짓기

스트루프 효과 - 색깔을 말하는 것보다 이름을 부르는 것이 잘 읽힘. 그러니까 이름을 지을 때는 표현하고 싶은 것을 더 명확하게 다듬기 위해 노력하자.

### 문화를 존중하라.

각 언어 사용자들이 선호하는 케이스를 무시하지 말기. (ex. 스네이크/카멜 케이스)

### 일관성

팀 내에서 특별한 의미가 있는 용어들을 비록하여 고유의 어휘를 모든 사람이 뜻을 알고 일관성 있게 사용해야 한다. → 팀 내 의사소통 중요. 짝 프로그래밍.

> **TIP74. 이름을 잘 지어라. 필요하면 이름을 바꿔라.**
> 

잘못된 이름을 바꿀 수없는 상황이라면 더 큰 문제. ETC 위반. 이름을 바꾸기 쉽게 만들자.
